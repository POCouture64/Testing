---
title: "Testing"
author: "POC"
format: html
editor: visual
---

## Testing

I will use this document to work on my SIMOA code since I am having trouble with it currently in the existing format. In this way I can mess around with this code and not be worried about it impacting my original data and now that I know what I want to do for my clusters it is easier for me to manipulate the variables in a manner that will set me up for success later.

## Loading the Data

The section I will use to lead the dataset that I will use for the analysis.

```{r}
#| label: Loading the Data and Libraries
######
# Loading required libraries and data
# In this section I will load all necessary packages and the dataset I want to use and name it "SIMOA" 
# so it is easier to call back on later and i know that this is my original dataset.
######

# Load all required libraries
library(readr)        # For reading CSV files
library(tidyverse)    # For data manipulation (dplyr, ggplot2, etc.)
library(mice)         # For multiple imputation
library(VIM)          # For visualizing missing data
library(naniar)       # For missing data exploration
library(effsize)      # For effect size calculations
library(ggplot2)      # For plotting (part of tidyverse but explicit)

# Load the dataset
SIMOA <- read_csv("SIMOA Report.csv")
#View(SIMOA)
```

## Eligible Participants

The section where I have set out the inclusion criteria to remove people from the dataset that do not meet our criteria.

```{r}
#| label: Eligible Participants
######
# In this section I will filter out those who have indicated they are <65 or that have not answered   
# yes to the question about age category or not answered either question. I will also filter out those 
# who did not select one of the 14 BZRAs listed because we do not want the results to be affected by 
# other sedating medications such as antihistamines or SSRI's.
######

# Original count
n_original <- nrow(SIMOA)

# After age filtering
SIMOA_age_filtered <- SIMOA %>%
  filter(age_cat == 1 | (age_cat == 0 & age >= 65))
n_after_age <- nrow(SIMOA_age_filtered)

# After both filters
SIMOA <- SIMOA_age_filtered %>%
  filter(rowSums(select(., starts_with("c_sp___"))[, 1:14] == 1, na.rm = TRUE) > 0)
n_final <- nrow(SIMOA)

# Report results
cat("Original sample:", n_original, "\n")
cat("After age filtering:", n_after_age, "(removed:", n_original - n_after_age, ")\n")
cat("After c_sp filtering:", n_final, "(removed:", n_after_age - n_final, ")\n")
cat("Total removed:", n_original - n_final, "\n")
```


## Calculating Subscale Scores

The section where I go about calculating the subscale scores for all the measures and ensure that this is properly done and that way I can compare the groups in subscales rather than the full measure and it makes it easier to report.

```{r}
#| label: Subscale Scores
######
# In this section I will get the subscale scores for all the measures I have used. I will also ensure
# that items are appropriately reverse-coded.
# All subscale score coding will be found in this chunk but I have divided them to make them easy to 
# find. I would rather have 1 chunk that way it cuts down on the amount of space being taken up for this step.
######

# First, let's create a working copy
data_personality <- SIMOA

######
# BFI-10 SUBSCALE SCORES
######

# Items to reverse: reserved, find_fault, lazy, relaxed, few_interests
# Formula: reversed_score = 6 - original_score
data_personality <- data_personality %>%
  mutate(
    reserved_rev = 6 - reserved,
    find_fault_rev = 6 - find_fault,
    lazy_rev = 6 - lazy,
    relaxed_rev = 6 - relaxed,
    few_interests_rev = 6 - few_interests
  )

# Verifying Reverse-Coding
data_personality %>%
  select(reserved, reserved_rev, find_fault, find_fault_rev, lazy, lazy_rev, 
         relaxed, relaxed_rev, few_interests, few_interests_rev) %>%
  head(10)

# Verify the math: original + reversed should equal 6
verification_check <- data_personality %>%
  mutate(
    reserved_sum = reserved + reserved_rev,
    find_fault_sum = find_fault + find_fault_rev,
    lazy_sum = lazy + lazy_rev,
    relaxed_sum = relaxed + relaxed_rev,
    few_interests_sum = few_interests + few_interests_rev
  ) %>%
  select(ends_with("_sum"))

cat("BFI-10 Reverse coding verification (all should equal 6):\n")
summary(verification_check)

# Creating personality total scores
data_personality <- data_personality %>%
  mutate(
    # Extraversion: reserved (reversed) + outgoing
    Extraversion = reserved_rev + outgoing,
    
    # Agreeableness: trusting + find_fault (reversed)
    Agreeableness = trusting + find_fault_rev,
    
    # Conscientiousness: lazy (reversed) + thorough
    Conscientiousness = lazy_rev + thorough,
    
    # Neuroticism: relaxed (reversed) + nervous
    Neuroticism = relaxed_rev + nervous,
    
    # Openness: few_interests (reversed) + imagination
    Openness = few_interests_rev + imagination
  )

######
# SURPS SUBSCALE SCORES
######

# First, reverse code SURPS Hopelessness items (all except surps17)
# Formula for 1-4 scale: reversed_score = 5 - original_score
data_personality <- data_personality %>%
  mutate(
    surps1_rev = 5 - surps1,
    surps4_rev = 5 - surps4,
    surps7_rev = 5 - surps7,
    surps13_rev = 5 - surps13,
    surps20_rev = 5 - surps20,
    surps23_rev = 5 - surps23
    # Note: surps17 is NOT reversed
  )

# Quick verification - all sums should equal 5
cat("SURPS reverse coding verification (all should equal 5):\n")
print(unique(data_personality$surps1 + data_personality$surps1_rev))
print(unique(data_personality$surps4 + data_personality$surps4_rev))
print(unique(data_personality$surps7 + data_personality$surps7_rev))

# Create SURPS total scores
data_personality <- data_personality %>%
  mutate(
    # Impulsivity: surps2, surps5, surps11, surps15, surps22
    SURPS_Impulsivity = surps2 + surps5 + surps11 + surps15 + surps22,
    
    # Sensation Seeking: surps3, surps6, surps9, surps12, surps16, surps19
    SURPS_Sensation_Seeking = surps3 + surps6 + surps9 + surps12 + surps16 + surps19,
    
    # Hopelessness: surps1(rev), surps4(rev), surps7(rev), surps13(rev), surps17, surps20(rev), surps23(rev)
    SURPS_Hopelessness = surps1_rev + surps4_rev + surps7_rev + surps13_rev + surps17 + surps20_rev + surps23_rev,
    
    # Anxiety Sensitivity: surps8, surps10, surps14, surps18, surps21
    SURPS_Anxiety_Sensitivity = surps8 + surps10 + surps14 + surps18 + surps21
  )

######
# DBAS SUBSCALE SCORES
######

# Response scale: 0-10 (0 = Strongly Disagree, 10 = Strongly Agree)
# No reverse coding needed for DBAS-16
data_personality <- data_personality %>%
  mutate(
    # Expectations subscale (2 items)
    DBAS_Expectations = rowMeans(select(., dbas1, dbas_2), na.rm = TRUE),
    
    # Medications subscale (3 items) 
    DBAS_Medications = rowMeans(select(., dbas_6, dbas_13, dbas_15), na.rm = TRUE),
    
    # Worry/Helplessness subscale (6 items)
    DBAS_Worry_Helplessness = rowMeans(select(., dbas_3, dbas_4, dbas_8, dbas_10, dbas_11, dbas_14), na.rm = TRUE),
    
    # Consequences subscale (5 items)
    DBAS_Consequences = rowMeans(select(., dbas_5, dbas_7, dbas_9, dbas_12, dbas_16), na.rm = TRUE)
  )

# DBAS verification
cat("DBAS-16 Subscale Summary:\n")
data_personality %>%
  select(DBAS_Expectations, DBAS_Medications, DBAS_Worry_Helplessness, DBAS_Consequences) %>%
  summary()

######
# CISS SUBSCALE SCORES
######

data_personality <- data_personality %>%
  mutate(
    # Avoidance Style: ciss1, ciss4, ciss7, ciss9, ciss15, ciss18, ciss21
    CISS_Avoidance_Style = ciss1 + ciss4 + ciss7 + ciss9 + ciss15 + ciss18 + ciss21,
    
    # Task Style: ciss2, ciss6, ciss8, ciss11, ciss13, ciss16, ciss19
    CISS_Task_Style = ciss2 + ciss6 + ciss8 + ciss11 + ciss13 + ciss16 + ciss19,
    
    # Emotional Style: ciss3, ciss5, ciss10, ciss12, ciss14, ciss17, ciss20
    CISS_Emotional_Style = ciss3 + ciss5 + ciss10 + ciss12 + ciss14 + ciss17 + ciss20
  )

# Calculate DBAS total score (sum of all subscales)
data_personality <- data_personality %>%
  mutate(
    # Total DBAS score (sum of all 4 subscales)
    dbas_score = DBAS_Expectations + DBAS_Medications + DBAS_Worry_Helplessness + DBAS_Consequences
  )

# Verification for DBAS total score
cat("DBAS Total Score Summary:\n")
summary(data_personality$dbas_score)
cat("Expected range: 0-10 (average of subscales) or sum of raw items\n\n")
```


## MICE Parameters Optimization

This section examines the data to determine the ideal number of iterations and imputations I should use on my code to ensure it is the ideal number.

```{r}
#| label: MICE Parameters Optimization
######
# Determine optimal number of imputations and iterations for MICE
######

# Quick initial analysis to estimate required imputations
# Rule of thumb: number of imputations should be at least equal to percentage of missing cases

# Calculate overall missingness
initial_dataset <- data_personality %>%
  select(all_of(c(
    "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", "DBAS_Medications",
    "Extraversion", "Agreeableness", "Conscientiousness", "Neuroticism", "Openness",
    "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", "SURPS_Anxiety_Sensitivity",
    "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
    "osss_3_score", "phq2_score", "age", "sex", "gender", "prov_terr", 
    "education", "employment", "driving_freq", "income"
  )))

# Calculate percentage of incomplete cases
incomplete_cases <- sum(!complete.cases(initial_dataset))
total_cases <- nrow(initial_dataset)
percent_incomplete <- round((incomplete_cases / total_cases) * 100, 1)

cat("=== MICE PARAMETER OPTIMIZATION ===\n")
cat("Total cases:", total_cases, "\n")
cat("Complete cases:", total_cases - incomplete_cases, "\n") 
cat("Incomplete cases:", incomplete_cases, "\n")
cat("Percentage incomplete:", percent_incomplete, "%\n\n")

# Recommend number of imputations
recommended_m <- max(5, ceiling(percent_incomplete))
if(recommended_m > 20) recommended_m <- 20  # Cap at reasonable maximum

cat("RECOMMENDATIONS:\n")
cat("Minimum imputations (m):", max(5, percent_incomplete), "\n")
cat("Recommended imputations (m):", recommended_m, "\n\n")

# Test convergence with different iteration numbers
cat("Testing convergence with different iteration numbers...\n")

# Convert categorical variables to factors for testing
test_dataset <- initial_dataset
categorical_vars <- c("sex", "gender", "prov_terr", "education", "employment", "driving_freq", "income")

for(var in categorical_vars) {
  if(var %in% names(test_dataset)) {
    test_dataset[[var]] <- as.factor(test_dataset[[var]])
  }
}

# Test with 5 iterations (quick test)
set.seed(123)
mice_test_5 <- mice(test_dataset, m = 3, maxit = 5, printFlag = FALSE)

# Test with 10 iterations  
set.seed(123)
mice_test_10 <- mice(test_dataset, m = 3, maxit = 10, printFlag = FALSE)

# Test with 20 iterations
set.seed(123)
mice_test_20 <- mice(test_dataset, m = 3, maxit = 20, printFlag = FALSE)

# Plot convergence (if you want to see plots, uncomment these lines)
plot(mice_test_5)
plot(mice_test_10) 
plot(mice_test_20)

# Check convergence statistics
cat("Convergence check complete.\n")
cat("Recommended iterations (maxit): 10-20 (check plots if convergence issues)\n\n")

cat("FINAL RECOMMENDATIONS:\n")
cat("Use m =", recommended_m, "imputations\n")
cat("Use maxit = 10 iterations (increase to 20 if convergence issues)\n")
cat("Monitor convergence plots if you notice unstable results\n\n")
```


## Missing Data Analysis

This section examines the missing data patterns before doing the multiple imputation to see if any special attention or statistics are required.

```{r}
#| label: Missing Data Analysis
######
# Examine missing data patterns before imputation
######

# Select variables for analysis
analysis_vars <- c(
  # DBAS scales (5 variables - including total score)
  "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", "DBAS_Medications", "dbas_score",
  # Personality scales (5 variables)
  "Extraversion", "Agreeableness", "Conscientiousness", "Neuroticism", "Openness",
  # SURPS scales (4 variables)
  "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", "SURPS_Anxiety_Sensitivity",
  # CISS scales (3 variables)
  "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
  # Additional variables (2 variables)
  "osss_3_score", "phq2_score",
  # Demographic variables (8 variables)
  "age", "sex", "gender", "prov_terr", "education", "employment", "driving_freq", "income"
  # Outcome variable
  #"scrn_stopped_bzra"
)

# I removed scrn_stopped_bzra because it is the outcome variable and should not be imputed because it may create artificial relationships, this is the prediction/analysis variable so imputing it would be circular reasoning, CI and other stats may be incorrect if the outcome is imputed.


# Create dataset with selected variables
final_dataset <- data_personality %>%
  select(all_of(analysis_vars))

# Examine missing data patterns
cat("=== MISSING DATA ANALYSIS ===\n")
cat("Total sample size:", nrow(final_dataset), "\n\n")

# Missing data summary
missing_summary <- final_dataset %>%
  summarise_all(~sum(is.na(.))) %>%
  gather(variable, missing_count) %>%
  mutate(missing_percent = round((missing_count / nrow(final_dataset)) * 100, 1)) %>%
  arrange(desc(missing_count))

print("Missing data by variable:")
print(missing_summary)

# Check missing data patterns
cat("\nMissing data patterns:\n")
md.pattern(final_dataset, rotate.names = TRUE)

# Visualize missing data (optional)
VIM::aggr(final_dataset, col = c('navyblue','red'), numbers = TRUE, sortVars = TRUE)
```


## Multiple Imputation

This section applies the findings from the previous 2 chunks to fill in the missing data and then reports the final dataset size.

```{r}
#| label: Multiple Imputation
######
# Apply MICE imputation for missing data
# Only including cases with valid scrn_stopped_bzra responses
######

# Filter to only include cases where scrn_stopped_bzra is not NA
cat("=== FILTERING FOR COMPLETE OUTCOME DATA ===\n")
cat("Original dataset size:", nrow(final_dataset), "\n")
cat("Cases with missing scrn_stopped_bzra:", sum(is.na(data_personality$scrn_stopped_bzra[1:nrow(final_dataset)])), "\n")

# Create indices for cases with valid outcome data
valid_outcome_indices <- which(!is.na(data_personality$scrn_stopped_bzra[1:nrow(final_dataset)]))

# Filter final_dataset to only include cases with valid outcome
final_dataset <- final_dataset[valid_outcome_indices, ]

cat("Filtered dataset size:", nrow(final_dataset), "\n")
cat("Cases removed due to missing outcome:", length(valid_outcome_indices) - nrow(final_dataset) + (nrow(data_personality) - length(valid_outcome_indices)), "\n")

# Set seed for reproducibility
set.seed(123)

# Convert categorical variables to factors
categorical_vars <- c("sex", "gender", "prov_terr", "education", "employment", "driving_freq", "income")
for(var in categorical_vars) {
  if(var %in% names(final_dataset)) {
    if(!is.factor(final_dataset[[var]])) {
      final_dataset[[var]] <- as.factor(final_dataset[[var]])
      cat(paste("Converted", var, "to factor\n"))
    }
  }
}

# Check if we have complete cases for comparison
complete_cases <- sum(complete.cases(final_dataset))
cat("Complete cases before imputation:", complete_cases, "out of", nrow(final_dataset), "\n")

# Apply MICE imputation
cat("\n=== RUNNING MICE IMPUTATION ===\n")
mice_result <- mice(final_dataset, m = 5, method = 'pmm', printFlag = FALSE, seed = 123)

# Get the completed dataset (using the first imputation)
final_dataset_imputed <- complete(mice_result, 1)

# Verify imputation worked
cat("\n=== IMPUTATION VERIFICATION ===\n")
cat("Missing values after MICE:\n")
print(sapply(final_dataset_imputed, function(x) sum(is.na(x))))

cat("\nFinal sample size:", nrow(final_dataset_imputed), "\n")

# Adding the outcome variable back to the imputed dataset for analysis
# Use the valid indices to get the corresponding outcome values
final_dataset_imputed$scrn_stopped_bzra <- data_personality$scrn_stopped_bzra[valid_outcome_indices]

# Verify no missing values in outcome
cat("Missing values in outcome variable:", sum(is.na(final_dataset_imputed$scrn_stopped_bzra)), "\n")
cat("Added outcome variable back to dataset for analysis\n")

# Final verification
cat("\n=== FINAL DATASET SUMMARY ===\n")
cat("Total cases in final imputed dataset:", nrow(final_dataset_imputed), "\n")
cat("Outcome variable distribution:\n")
print(table(final_dataset_imputed$scrn_stopped_bzra, useNA = "ifany"))
```


## Secondary Variables

This section adds variables about adverse effects, dependence, negative daytime experiences, substance use, sleep-related substance use.

These variables could not be imputed because they are not MAR and since they are MNAR multiple imputation is not ideal to analyze the missingness.

```{r}
#| label: Secondary Variable Code
######
# Add adverse effects and substance use variables back to imputed dataset
# These variables are not imputed due to MNAR patterns but kept for secondary analyses
######
cat("=== ADDING SECONDARY VARIABLES FOR CLUSTER ANALYSIS ===\n")

# Define all secondary variables we want to add
secondary_vars_to_add <- c(
  # Adverse effects - current users
  "side_effects_1", "side_effects_2", "side_effects_3", "side_effects_4",
  "safety_1", "safety_2", "safety_3", "safety_4", "adls_1", "adls_2", 
  "dependence_1", "dependence_2", "dependence_3",
  # Adverse effects - past users (v2 versions)
  "side_effects_1_v2", "side_effects_2_v2", "side_effects_3_v2", "side_effects_4_v2",
  "safety_1_v2", "safety_2_v2", "safety_3_v2", "safety_4_v2", "adls_1_v2", "adls_2_v2",
  "dependence_1_v2", "dependence_2_v2", "dependence_3_v2",
  # Substance use variables
  "med_quant", "op_use", "can_use", "alc_use_wmn", "alc_use_men",
  "alc_sleep", "can_sleep", "melatonin_use", "op_sleep", "quet_use", "traz_use", "otc_use"
)

# Check which variables exist in original dataset
existing_secondary_vars <- secondary_vars_to_add[secondary_vars_to_add %in% names(data_personality)]

cat("Secondary variables found in data_personality:", length(existing_secondary_vars), "\n")
if(length(existing_secondary_vars) > 0) {
  cat("Variables found:\n")
  print(existing_secondary_vars)
}

# Add variables back to imputed dataset using the same indexing as before
if(length(existing_secondary_vars) > 0) {
  cat("\n=== ADDING VARIABLES TO IMPUTED DATASET ===\n")
  
  # Use the same valid_outcome_indices from the multiple imputation step
  for(var in existing_secondary_vars) {
    # Get the source data using the same indices as the imputed dataset
    source_data <- data_personality[[var]][valid_outcome_indices]
    
    # Add to imputed dataset
    final_dataset_imputed[[var]] <- source_data
    
    missing_count <- sum(is.na(source_data))
    non_missing <- sum(!is.na(source_data))
    cat(sprintf("Added %s: %d non-missing, %d missing\n", var, non_missing, missing_count))
  }
} else {
  cat("No secondary variables found to add\n")
}

# COMBINE GENDER-SPECIFIC ALCOHOL VARIABLES
cat("\n=== COMBINING GENDER-SPECIFIC ALCOHOL VARIABLES ===\n")
if("alc_use_wmn" %in% names(final_dataset_imputed) && "alc_use_men" %in% names(final_dataset_imputed)) {
  # Create combined alcohol variable based on sex
  # sex = 1 shows alc_use_wmn, sex = 2 shows alc_use_men
  final_dataset_imputed$alc_use_combined <- ifelse(
    final_dataset_imputed$sex == 1, 
    final_dataset_imputed$alc_use_wmn,
    final_dataset_imputed$alc_use_men
  )
  
  # Check the combination worked
  wmn_data_count <- sum(!is.na(final_dataset_imputed$alc_use_wmn))
  men_data_count <- sum(!is.na(final_dataset_imputed$alc_use_men))
  combined_data_count <- sum(!is.na(final_dataset_imputed$alc_use_combined))
  
  cat(sprintf("Original alc_use_wmn: %d non-missing\n", wmn_data_count))
  cat(sprintf("Original alc_use_men: %d non-missing\n", men_data_count))
  cat(sprintf("Combined alc_use_combined: %d non-missing\n", combined_data_count))
  
  # Remove the original gender-specific variables
  final_dataset_imputed$alc_use_wmn <- NULL
  final_dataset_imputed$alc_use_men <- NULL
  
  cat("✓ Gender-specific alcohol variables combined and originals removed\n")
} else {
  cat("Gender-specific alcohol variables not found\n")
}

# Define adverse effects variable pairs for combination
adverse_var_pairs <- list(
  side_effects_1_combined = c("side_effects_1", "side_effects_1_v2"),
  side_effects_2_combined = c("side_effects_2", "side_effects_2_v2"),
  side_effects_3_combined = c("side_effects_3", "side_effects_3_v2"),
  side_effects_4_combined = c("side_effects_4", "side_effects_4_v2"),
  safety_1_combined = c("safety_1", "safety_1_v2"),
  safety_2_combined = c("safety_2", "safety_2_v2"),
  safety_3_combined = c("safety_3", "safety_3_v2"),
  safety_4_combined = c("safety_4", "safety_4_v2"),
  adls_1_combined = c("adls_1", "adls_1_v2"),
  adls_2_combined = c("adls_2", "adls_2_v2"),
  dependence_1_combined = c("dependence_1", "dependence_1_v2"),
  dependence_2_combined = c("dependence_2", "dependence_2_v2"),
  dependence_3_combined = c("dependence_3", "dependence_3_v2")
)

cat("\n=== COMBINING ADVERSE EFFECTS VARIABLES ===\n")

# Track successfully combined variables
combined_adverse_vars_cluster <- character(0)

# Process each adverse effects variable pair
for(combined_name in names(adverse_var_pairs)) {
  current_var <- adverse_var_pairs[[combined_name]][1]
  past_var <- adverse_var_pairs[[combined_name]][2]
  
  cat("Processing", combined_name, "...\n")
  
  current_exists <- current_var %in% names(final_dataset_imputed)
  past_exists <- past_var %in% names(final_dataset_imputed)
  
  if(current_exists && past_exists) {
    # Get the data
    current_data <- final_dataset_imputed[[current_var]]
    past_data <- final_dataset_imputed[[past_var]]
    outcome_data <- final_dataset_imputed$scrn_stopped_bzra
    
    # Create combined variable
    combined_data <- rep(NA, nrow(final_dataset_imputed))
    
    # For current users (scrn_stopped_bzra == 0), use current version
    current_user_indices <- which(outcome_data == 0)
    if(length(current_user_indices) > 0) {
      combined_data[current_user_indices] <- current_data[current_user_indices]
    }
    
    # For past users (scrn_stopped_bzra == 1), use past version  
    past_user_indices <- which(outcome_data == 1)
    if(length(past_user_indices) > 0) {
      combined_data[past_user_indices] <- past_data[past_user_indices]
    }
    
    # Add to dataset
    final_dataset_imputed[[combined_name]] <- combined_data
    combined_adverse_vars_cluster <- c(combined_adverse_vars_cluster, combined_name)
    
    # Remove original versions to avoid confusion
    final_dataset_imputed[[current_var]] <- NULL
    final_dataset_imputed[[past_var]] <- NULL
    
    missing_count <- sum(is.na(combined_data))
    non_missing <- sum(!is.na(combined_data))
    cat(sprintf("✓ Created %s: %d non-missing, %d missing\n", combined_name, non_missing, missing_count))
    
  } else if(current_exists) {
    # Only current version exists
    final_dataset_imputed[[combined_name]] <- final_dataset_imputed[[current_var]]
    final_dataset_imputed[[current_var]] <- NULL
    combined_adverse_vars_cluster <- c(combined_adverse_vars_cluster, combined_name)
    cat(sprintf("✓ Used current version for %s\n", combined_name))
    
  } else if(past_exists) {
    # Only past version exists
    final_dataset_imputed[[combined_name]] <- final_dataset_imputed[[past_var]]
    final_dataset_imputed[[past_var]] <- NULL
    combined_adverse_vars_cluster <- c(combined_adverse_vars_cluster, combined_name)
    cat(sprintf("✓ Used past version for %s\n", combined_name))
    
  } else {
    cat(sprintf("✗ Neither version exists for %s\n", combined_name))
  }
}

# Get substance use variables (updated to include combined alcohol variable)
substance_vars_cluster <- names(final_dataset_imputed)[grepl("alc_|can_|op_|med_|melatonin|quet|traz|otc", names(final_dataset_imputed))]

cat("\n=== CLUSTER ANALYSIS VARIABLES SUMMARY ===\n")
cat("Combined adverse effects variables:", length(combined_adverse_vars_cluster), "\n")
if(length(combined_adverse_vars_cluster) > 0) {
  cat("Adverse effects variables:\n")
  for(var in combined_adverse_vars_cluster) {
    missing_count <- sum(is.na(final_dataset_imputed[[var]]))
    non_missing <- sum(!is.na(final_dataset_imputed[[var]]))
    cat(sprintf("  %s: %d non-missing, %d missing\n", var, non_missing, missing_count))
  }
}

cat("\nSubstance use variables:", length(substance_vars_cluster), "\n")
if(length(substance_vars_cluster) > 0) {
  cat("Substance use variables:\n")
  for(var in substance_vars_cluster) {
    missing_count <- sum(is.na(final_dataset_imputed[[var]]))
    non_missing <- sum(!is.na(final_dataset_imputed[[var]]))
    cat(sprintf("  %s: %d non-missing, %d missing\n", var, non_missing, missing_count))
  }
}

# Create cluster analysis dataset
cat("\n=== CREATING CLUSTER ANALYSIS DATASET ===\n")

# Core variables for cluster analysis (imputed, so complete)
core_cluster_vars <- c(
  # DBAS scales
  "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", "DBAS_Medications",
  # Personality
  "Extraversion", "Agreeableness", "Conscientiousness", "Neuroticism", "Openness",
  # SURPS
  "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", "SURPS_Anxiety_Sensitivity",
  # CISS
  "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
  # Other scales
  "osss_3_score", "phq2_score",
  # Demographics
  "age", "sex",
  # Outcome
  "scrn_stopped_bzra"
)

# Check which core variables exist
existing_core_cluster <- core_cluster_vars[core_cluster_vars %in% names(final_dataset_imputed)]

# Combine all variables for cluster analysis
all_cluster_vars <- c(existing_core_cluster, combined_adverse_vars_cluster, substance_vars_cluster)

# Create cluster analysis dataset with complete cases only for secondary variables
cluster_analysis_data <- final_dataset_imputed %>%
  select(all_of(all_cluster_vars)) %>%
  # Keep all cases for core variables (they're imputed), but require complete cases for secondary variables
  filter(if(length(c(combined_adverse_vars_cluster, substance_vars_cluster)) > 0) {
    complete.cases(select(., all_of(c(combined_adverse_vars_cluster, substance_vars_cluster))))
  } else {
    TRUE
  })

cat("Cluster analysis dataset created:\n")
cat("Total variables:", length(all_cluster_vars), "\n")
cat("- Core variables (imputed):", length(existing_core_cluster), "\n")
cat("- Adverse effects variables:", length(combined_adverse_vars_cluster), "\n") 
cat("- Substance use variables:", length(substance_vars_cluster), "\n")
cat("Complete cases:", nrow(cluster_analysis_data), "out of", nrow(final_dataset_imputed), "total\n")

# Save datasets to global environment
assign("final_dataset_imputed", final_dataset_imputed, envir = .GlobalEnv)
assign("cluster_analysis_data", cluster_analysis_data, envir = .GlobalEnv)
assign("combined_adverse_vars_cluster", combined_adverse_vars_cluster, envir = .GlobalEnv)
assign("substance_vars_cluster", substance_vars_cluster, envir = .GlobalEnv)

cat("\n✓ All variables prepared for cluster analysis\n")
cat("✓ final_dataset_imputed updated with combined variables\n")
cat("✓ cluster_analysis_data ready for cluster analysis\n")

# Final verification
cat("\nFinal dataset dimensions:", nrow(final_dataset_imputed), "x", ncol(final_dataset_imputed), "\n")
cat("Variables available for clustering:\n")
if(length(combined_adverse_vars_cluster) > 0) {
  cat("- Adverse effects (combined):", paste(head(combined_adverse_vars_cluster, 5), collapse = ", "))
  if(length(combined_adverse_vars_cluster) > 5) cat("... and", length(combined_adverse_vars_cluster) - 5, "more")
  cat("\n")
}
if(length(substance_vars_cluster) > 0) {
  cat("- Substance use:", paste(head(substance_vars_cluster, 5), collapse = ", "))
  if(length(substance_vars_cluster) > 5) cat("... and", length(substance_vars_cluster) - 5, "more")
  cat("\n")
}
```


## Data Preperation

The section where I will change some of the variables to different groupings. I will change the regional groupings to regions of the country rather than each province, I will change the educational groupings to simply <High School or Trade/Uni, and I will change employment to Full/Part Time Work or Not Employed/Retired.

```{r}
#| label: Data Preparation for Analysis 
######
# Prepare data with grouped variables
# Variables already detected in previous step
######

library(dplyr)

cat("=== DATA PREPARATION ===\n")
cat("Dataset dimensions:", nrow(final_dataset_imputed), "rows,", ncol(final_dataset_imputed), "columns\n")

# Variables are already set from previous step, just verify
cat("Using variables from secondary analysis step:\n")
cat("- Combined adverse effects variables:", length(combined_adverse_vars), "\n")
cat("- Substance use variables:", length(substance_vars), "\n")
cat("- Final numeric variables:", length(final_numeric_vars), "\n")

# --- Regional groupings ---
if("prov_terr" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$prov_terr_region <- case_when(
    final_dataset_imputed$prov_terr %in% c(1, 2, 3, 12) ~ "Prairies",
    final_dataset_imputed$prov_terr %in% c(9, 11) ~ "Central Canada", 
    final_dataset_imputed$prov_terr %in% c(4, 5, 7, 10) ~ "Atlantic Canada",
    final_dataset_imputed$prov_terr %in% c(6, 8, 13) ~ "Territories",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$prov_terr_region <- factor(final_dataset_imputed$prov_terr_region,
                                                   levels = c("Prairies", "Central Canada", 
                                                              "Atlantic Canada", "Territories"))
  cat("✓ Created regional groupings\n")
}

# --- Education groupings ---
if("education" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$education_level <- case_when(
    final_dataset_imputed$education %in% c(1, 2, 3) ~ "High School or Less",
    final_dataset_imputed$education %in% c(4, 5) ~ "Trade School/University",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$education_level <- factor(final_dataset_imputed$education_level,
                                                  levels = c("High School or Less", "Trade School/University"))
  cat("✓ Created education level groupings\n")
}

# --- Employment groupings ---
if("employment" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$employment_status <- case_when(
    final_dataset_imputed$employment %in% c(0, 3, 4) ~ "Retired/Not in Workforce",
    final_dataset_imputed$employment %in% c(1, 2) ~ "Full- or Part-Time",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$employment_status <- factor(final_dataset_imputed$employment_status,
                                                    levels = c("Full- or Part-Time", "Retired/Not in Workforce"))
  cat("✓ Created employment status groupings\n")
}

# Verify outcome variable is properly coded
if("scrn_stopped_bzra" %in% names(final_dataset_imputed)) {
  cat("\n✓ Outcome variable verification:\n")
  cat("Missing values in scrn_stopped_bzra:", sum(is.na(final_dataset_imputed$scrn_stopped_bzra)), "\n")
  cat("Distribution of scrn_stopped_bzra:\n")
  print(table(final_dataset_imputed$scrn_stopped_bzra, useNA = "ifany"))
}

cat("\nData preparation complete!\n")
```


## Entire Group Descriptives

This section of the code will present all the descriptive statistics for the entire group with the variables about adverse effects, dependence, negative daytime experiences, substance use, sleep-related substance use added to the core personality and demographics data. 

```{r}
#| label: Entire Group Descriptives
######
# This chunk describes the entire sample (no grouping by BZRA status).
# It separates variables into: 
#   1. Continuous
#   2. Ordinal (frequency/attitudes)
#   3. Categorical (demographics)
######

library(dplyr)

cat("=== ENTIRE SAMPLE DESCRIPTIVE STATISTICS ===\n")
cat("Sample size:", nrow(final_dataset_imputed), "\n")

# Identify numeric variables
numeric_vars <- names(final_dataset_imputed)[sapply(final_dataset_imputed, is.numeric)]
# Remove categorical numeric variables (Likert/radio) from numeric summary
categorical_numeric_vars <- c(
  "op_use", "can_use", "alc_sleep", "can_sleep", "melatonin_use", "op_sleep",
  "quet_use", "traz_use", "otc_use",
  "side_effects_1_combined", "side_effects_2_combined", "side_effects_3_combined", "side_effects_4_combined",
  "safety_1_combined", "safety_2_combined", "safety_3_combined", "safety_4_combined",
  "adls_1_combined", "adls_2_combined",
  "dependence_1_combined", "dependence_2_combined", "dependence_3_combined",
  "alc_use_combined"
)
numeric_vars <- setdiff(numeric_vars, categorical_numeric_vars)

# Numeric variables summary
if(length(numeric_vars) > 0) {
  cat("\nNUMERIC VARIABLES:\n")
  for(var in numeric_vars) {
    x <- final_dataset_imputed[[var]]
    cat(var, "-> Mean:", round(mean(x, na.rm=TRUE),2),
        "SD:", round(sd(x, na.rm=TRUE),2),
        "Min:", round(min(x, na.rm=TRUE),2),
        "Max:", round(max(x, na.rm=TRUE),2), "\n")
  }
}

# Automatically identify categorical variables
auto_categorical_vars <- names(final_dataset_imputed)[sapply(final_dataset_imputed, function(x) {
  is.factor(x) || (is.numeric(x) && length(unique(x[!is.na(x)])) <= 6)
})]
# Remove numeric variables
auto_categorical_vars <- setdiff(auto_categorical_vars, numeric_vars)

# Categorical variables summary
cat("\nCATEGORICAL VARIABLES:\n")
for(var in auto_categorical_vars) {
  if(var %in% names(final_dataset_imputed)) {
    cat("\n", var, ":\n")
    counts <- table(final_dataset_imputed[[var]], useNA = "ifany")
    perc <- round(prop.table(counts) * 100, 1)
    for(i in seq_along(counts)) {
      cat("  ", names(counts)[i], ": ", counts[i], " (", perc[i], "%)\n", sep = "")
    }
  }
}

# === ALCOHOL USE DESCRIPTIVES (separate by sex using alc_use_combined) ===
cat("\n--- ALCOHOL USE (separate by sex using alc_use_combined) ---\n")

cat("\nAlcohol Use - Women:\n")
if("alc_use_combined" %in% names(final_dataset_imputed)) {
  counts_w <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 1], useNA = "ifany")
  perc_w <- round(prop.table(counts_w) * 100, 1)
  for(i in seq_along(counts_w)) {
    cat("  ", names(counts_w)[i], ": ", counts_w[i], " (", perc_w[i], "%)\n", sep = "")
  }
}

cat("\nAlcohol Use - Men:\n")
if("alc_use_combined" %in% names(final_dataset_imputed)) {
  counts_m <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 2], useNA = "ifany")
  perc_m <- round(prop.table(counts_m) * 100, 1)
  for(i in seq_along(counts_m)) {
    cat("  ", names(counts_m)[i], ": ", counts_m[i], " (", perc_m[i], "%)\n", sep = "")
  }
}

cat("\n=== DESCRIPTIVES COMPLETE ===\n")
```


## Group Comparison Descriptives

This section will split the groups based on their answer to scrn_stopped_bzra.

```{r}
#| label: Descriptives by BZRA status with effect sizes
######
# Descriptive statistics for the entire sample, divided by BZRA status
# (scrn_stopped_bzra), including numeric effect sizes (Cohen's d)
######

library(dplyr)
library(effsize)

cat("=== DESCRIPTIVES BY BZRA STATUS ===\n")
cat("Sample size:", nrow(final_dataset_imputed), "\n")

# Convert factor to numeric for proper filtering
final_dataset_imputed$scrn_stopped_bzra_numeric <- as.numeric(final_dataset_imputed$scrn_stopped_bzra) - 1

# Verify the conversion
cat("\nVerifying conversion:\n")
conversion_check <- table(final_dataset_imputed$scrn_stopped_bzra, 
                         final_dataset_imputed$scrn_stopped_bzra_numeric, 
                         useNA = "always")
print(conversion_check)
cat("Current Users (0):", sum(final_dataset_imputed$scrn_stopped_bzra_numeric == 0), "\n")
cat("Past Users (1):", sum(final_dataset_imputed$scrn_stopped_bzra_numeric == 1), "\n")

# List of numeric and categorical variables
numeric_vars <- c("age", "DBAS_Consequences", "DBAS_Worry_Helplessness",
                  "DBAS_Expectations", "DBAS_Medications", "dbas_score",
                  "Extraversion", "Agreeableness", "Conscientiousness",
                  "Neuroticism", "Openness", "SURPS_Impulsivity",
                  "SURPS_Sensation_Seeking", "SURPS_Hopelessness",
                  "SURPS_Anxiety_Sensitivity", "CISS_Avoidance_Style",
                  "CISS_Task_Style", "CISS_Emotional_Style", "osss_3_score",
                  "phq2_score", "med_quant")

categorical_vars <- c("sex", "gender", "prov_terr_region", "education_level", 
                      "employment_status", "driving_freq", "income", 
                      "op_use", "can_use", "alc_sleep", "can_sleep",
                      "melatonin_use", "op_sleep", "quet_use", "traz_use",
                      "otc_use", "side_effects_1_combined", "side_effects_2_combined",
                      "side_effects_3_combined", "side_effects_4_combined",
                      "safety_1_combined", "safety_2_combined", "safety_3_combined",
                      "safety_4_combined", "adls_1_combined", "adls_2_combined",
                      "dependence_1_combined", "dependence_2_combined",
                      "dependence_3_combined", "alc_use_combined")

# Ensure numeric variables are truly numeric
for(var in numeric_vars) {
  if(var %in% names(final_dataset_imputed)) {
    final_dataset_imputed[[var]] <- suppressWarnings(as.numeric(as.character(final_dataset_imputed[[var]])))
  }
}

# NUMERIC VARIABLES
cat("\nNUMERIC VARIABLES:\n")
for(var in numeric_vars) {
  if(var %in% names(final_dataset_imputed)) {
    x1 <- final_dataset_imputed[[var]][final_dataset_imputed$scrn_stopped_bzra_numeric == 1]  # Past users
    x0 <- final_dataset_imputed[[var]][final_dataset_imputed$scrn_stopped_bzra_numeric == 0]  # Current users
    
    # Remove NA values
    x1_clean <- x1[!is.na(x1)]
    x0_clean <- x0[!is.na(x0)]
    
    # Only compute if at least one non-NA value in each group
    if(length(x1_clean) > 0 & length(x0_clean) > 0) {
      # Basic descriptives
      mean1 <- round(mean(x1_clean),2)
      mean0 <- round(mean(x0_clean),2)
      sd1 <- round(sd(x1_clean),2)
      sd0 <- round(sd(x0_clean),2)
      n1 <- length(x1_clean)
      n0 <- length(x0_clean)
      
      # Mean difference
      mean_diff <- round(mean1 - mean0, 2)
      
      # Standard error of the mean for each group
      se1 <- sd1/sqrt(n1)
      se0 <- sd0/sqrt(n0)
      
      # 95% Confidence intervals for means
      ci1_lower <- round(mean1 - 1.96*se1, 2)
      ci1_upper <- round(mean1 + 1.96*se1, 2)
      ci0_lower <- round(mean0 - 1.96*se0, 2)
      ci0_upper <- round(mean0 + 1.96*se0, 2)
      
      # Confidence interval for the mean difference (independent samples)
      se_diff <- sqrt((sd1^2/n1) + (sd0^2/n0))
      ci_diff_lower <- round(mean_diff - 1.96*se_diff, 2)
      ci_diff_upper <- round(mean_diff + 1.96*se_diff, 2)
      
      # Cohen's d
      d_val <- tryCatch({
        round(cohen.d(x1_clean, x0_clean)$estimate,2)
      }, error=function(e) NA)
      
      # t-test for p-value
      t_test <- tryCatch({
        t.test(x1_clean, x0_clean)
      }, error=function(e) NULL)
      
      # Format p-value appropriately
      p_val <- if(!is.null(t_test)) {
        if(t_test$p.value < 0.001) {
          "< 0.001"
        } else {
          round(t_test$p.value, 4)
        }
      } else NA
      
      cat(var, ":\n")
      cat("  Past Users: M =", mean1, "(95% CI:", ci1_lower, "to", ci1_upper, "), SD =", sd1, ", n =", n1, "\n")
      cat("  Current Users: M =", mean0, "(95% CI:", ci0_lower, "to", ci0_upper, "), SD =", sd0, ", n =", n0, "\n")
      cat("  Mean Difference:", mean_diff, "(95% CI:", ci_diff_lower, "to", ci_diff_upper, ")\n")
      cat("  Cohen's d:", d_val, ", p-value:", p_val, "\n\n")
    } else {
      cat(var, "-> Not enough data to calculate statistics\n")
    }
  }
}

# CATEGORICAL VARIABLES
cat("\nCATEGORICAL VARIABLES:\n")
for(var in categorical_vars) {
  if(var %in% names(final_dataset_imputed)) {
    cat("\n", var, ":\n")
    
    counts_0 <- table(final_dataset_imputed[[var]][final_dataset_imputed$scrn_stopped_bzra_numeric == 0], useNA = "ifany")  # Current users
    counts_1 <- table(final_dataset_imputed[[var]][final_dataset_imputed$scrn_stopped_bzra_numeric == 1], useNA = "ifany")  # Past users
    
    perc_0 <- round(prop.table(counts_0) * 100, 1)
    perc_1 <- round(prop.table(counts_1) * 100, 1)
    
    all_levels <- union(names(counts_0), names(counts_1))
    
    df <- data.frame(
      Category = all_levels,
      Current_Count = sapply(all_levels, function(x) if(x %in% names(counts_0)) counts_0[x] else 0),
      Current_Percent = sapply(all_levels, function(x) if(x %in% names(perc_0)) perc_0[x] else 0),
      Past_Count = sapply(all_levels, function(x) if(x %in% names(counts_1)) counts_1[x] else 0),
      Past_Percent = sapply(all_levels, function(x) if(x %in% names(perc_1)) perc_1[x] else 0)
    )
    
    print(df)
    
    # Calculate Cramér's V for categorical variables (if both groups have data)
    if(length(counts_0) > 0 & length(counts_1) > 0) {
      # Create contingency table
      cont_table <- tryCatch({
        table(final_dataset_imputed[[var]], final_dataset_imputed$scrn_stopped_bzra_numeric)
      }, error=function(e) NULL)
      
      if(!is.null(cont_table) && sum(cont_table) > 0) {
        # Run chi-square test once with warning suppression
        chi_result <- tryCatch({
          suppressWarnings(chisq.test(cont_table))
        }, error=function(e) NULL)
        
        if(!is.null(chi_result)) {
          min_expected <- min(chi_result$expected)
          
          # Use Fisher's exact test for 2x2 tables or when assumptions violated
          if((nrow(cont_table) == 2 && ncol(cont_table) == 2) || min_expected < 5) {
            # Fisher's exact test for 2x2 tables
            if(nrow(cont_table) == 2 && ncol(cont_table) == 2) {
              fisher_test <- tryCatch({
                fisher.test(cont_table)
              }, error=function(e) NULL)
              
              if(!is.null(fisher_test)) {
                cat("Fisher's exact test p-value:", round(fisher_test$p.value, 4))
              }
            } else {
              cat("Expected counts too low for reliable chi-square test (min expected =", round(min_expected, 1), ")")
            }
          } else {
            # Chi-square test when assumptions are met
            cat("Chi-square p-value:", round(chi_result$p.value, 4))
          }
          
          # Calculate Cramér's V using the already computed chi-square statistic
          if(!is.na(chi_result$statistic)) {
            cramers_v <- sqrt(chi_result$statistic / (sum(cont_table) * (min(dim(cont_table)) - 1)))
            cat(", Cramér's V:", round(cramers_v, 3), "\n")
          } else {
            cat("\n")}}}}}}
cat("\n=== DESCRIPTIVES COMPLETE ===\n")
```


## Cluster Analysis

This section will be used for my cluster analysis. I will start by removing the outcome variable and then running a cluster analysis only on the personality/demographic variables to see what emerges from that. I will then add secondary variables with missingness <25% to see if adverse effects or substance use variables add/remove from the cluster and then I will test to see if there is an association between the cluster and cessation outcome.

After running this code I will still need to: 
- Standardize variables (especially if the scale check shows large    differences)
- Determine optimal k using multiple methods
- Apply clustering and assess stability
- Test association between discovered clusters and cessation status
- Characterize clusters using all available secondary variables

Here is the code I will use to harmonize the alc_use variables because men and women have slightly different scales.

=== HARMONIZED ALCOHOL USE VARIABLE ===
Convert to approximate drinks per week for modeling
final_dataset_imputed <- final_dataset_imputed %>%
  mutate(
    alc_use_harmonized = case_when(
      sex == 1 & alc_use_wmn == 0 ~ 0,   # Never
      sex == 1 & alc_use_wmn == 1 ~ 0.5, # <1 per week
      sex == 1 & alc_use_wmn == 2 ~ 3,   # 1–5
      sex == 1 & alc_use_wmn == 3 ~ 8,   # 6–10
      sex == 1 & alc_use_wmn == 4 ~ 12,  # >10

      sex == 2 & alc_use_men == 1 ~ 0,   # Never
      sex == 2 & alc_use_men == 2 ~ 0.5, # <1 per week
      sex == 2 & alc_use_men == 3 ~ 4,   # 1–7
      sex == 2 & alc_use_men == 4 ~ 11,  # 8–14
      sex == 2 & alc_use_men == 5 ~ 16,  # >14

      TRUE ~ NA_real_
    


```{r}
#| label: Cluster Analysis
######
# UNSUPERVISED CLUSTER ANALYSIS - OUTCOME-AGNOSTIC APPROACH
# Remove outcome variable to allow natural phenotype discovery
######

cat("=== UNSUPERVISED CLUSTER ANALYSIS PREPARATION ===\n")
cat("Strategy: Remove outcome variable, cluster on intrinsic characteristics\n")
cat("Then test association between clusters and cessation status\n\n")

# CLUSTERING VARIABLES (excluding outcome)
clustering_vars_core <- c(
  # DBAS scales
  "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", "DBAS_Medications",
  # Personality
  "Extraversion", "Agreeableness", "Conscientiousness", "Neuroticism", "Openness",
  # SURPS
  "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", "SURPS_Anxiety_Sensitivity",
  # CISS
  "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
  # Other scales
  "osss_3_score", "phq2_score",
  # Demographics
  "age", "sex"
  # NOTE: scrn_stopped_bzra deliberately excluded
)

# VALIDATION VARIABLES (to characterize clusters post-hoc)
validation_vars <- c(
  "scrn_stopped_bzra"  # Primary outcome for validation
)

# Check which core clustering variables exist
existing_clustering_vars <- clustering_vars_core[clustering_vars_core %in% names(final_dataset_imputed)]

cat("CORE CLUSTERING VARIABLES (outcome-agnostic):\n")
cat("Variables available:", length(existing_clustering_vars), "\n")
for(var in existing_clustering_vars) {
  cat(sprintf("  %s\n", var))
}

# Create core clustering dataset (no outcome variable)
cluster_data_unsupervised <- final_dataset_imputed %>%
  select(all_of(existing_clustering_vars))

cat("\nCORE CLUSTERING DATASET:\n")
cat("Participants:", nrow(cluster_data_unsupervised), "\n")
cat("Variables:", ncol(cluster_data_unsupervised), "\n")
cat("Complete cases: 100% (from imputation)\n")

# ANALYZE SECONDARY VARIABLES FOR POTENTIAL INCLUSION
cat("\n=== SECONDARY VARIABLE ANALYSIS FOR CLUSTERING ===\n")

# Define completeness threshold
missing_threshold <- 0.25  # Allow up to 25% missing for secondary variables

# Analyze adverse effects completeness
adverse_analysis <- data.frame(
  variable = character(),
  n_complete = numeric(),
  prop_complete = numeric(),
  include_in_clustering = logical(),
  stringsAsFactors = FALSE
)

if(length(combined_adverse_vars_cluster) > 0) {
  cat("ADVERSE EFFECTS VARIABLES:\n")
  for(var in combined_adverse_vars_cluster) {
    if(var %in% names(final_dataset_imputed)) {
      complete_count <- sum(!is.na(final_dataset_imputed[[var]]))
      prop_complete <- complete_count / nrow(final_dataset_imputed)
      include_var <- prop_complete >= (1 - missing_threshold)
      
      adverse_analysis <- rbind(adverse_analysis, 
                               data.frame(variable = var,
                                        n_complete = complete_count,
                                        prop_complete = prop_complete,
                                        include_in_clustering = include_var))
      
      status <- ifelse(include_var, "✓ INCLUDE", "✗ EXCLUDE")
      cat(sprintf("  %s: %.1f%% complete - %s\n", var, prop_complete*100, status))
    }
  }
}

# Analyze substance use completeness
substance_analysis <- data.frame(
  variable = character(),
  n_complete = numeric(),
  prop_complete = numeric(),
  include_in_clustering = logical(),
  stringsAsFactors = FALSE
)

if(length(substance_vars_cluster) > 0) {
  cat("\nSUBSTANCE USE VARIABLES:\n")
  for(var in substance_vars_cluster) {
    if(var %in% names(final_dataset_imputed)) {
      complete_count <- sum(!is.na(final_dataset_imputed[[var]]))
      prop_complete <- complete_count / nrow(final_dataset_imputed)
      include_var <- prop_complete >= (1 - missing_threshold)
      
      substance_analysis <- rbind(substance_analysis, 
                                 data.frame(variable = var,
                                          n_complete = complete_count,
                                          prop_complete = prop_complete,
                                          include_in_clustering = include_var))
      
      status <- ifelse(include_var, "✓ INCLUDE", "✗ EXCLUDE")
      cat(sprintf("  %s: %.1f%% complete - %s\n", var, prop_complete*100, status))
    }
  }
}

# Identify variables suitable for clustering
suitable_adverse <- adverse_analysis$variable[adverse_analysis$include_in_clustering]
suitable_substance <- substance_analysis$variable[substance_analysis$include_in_clustering]
suitable_secondary <- c(suitable_adverse, suitable_substance)

cat("\n=== CLUSTERING STRATEGY SUMMARY ===\n")

# STRATEGY A: Core variables only (most robust)
cat("STRATEGY A - Core psychological/demographic variables only:\n")
cat("  Variables:", length(existing_clustering_vars), "\n")
cat("  Sample size: 398 (100% complete)\n")
cat("  Strengths: Robust, theory-driven, complete data\n")
cat("  Use for: Primary phenotype discovery\n")

# STRATEGY B: Core + suitable secondary variables (if any)
if(length(suitable_secondary) > 0) {
  all_clustering_vars <- c(existing_clustering_vars, suitable_secondary)
  
  # Create extended clustering dataset
  cluster_data_extended <- final_dataset_imputed %>%
    select(all_of(all_clustering_vars)) %>%
    filter(complete.cases(.))
  
  cat("\nSTRATEGY B - Core + high-completeness secondary variables:\n")
  cat("  Variables:", length(all_clustering_vars), "\n")
  cat("  - Core:", length(existing_clustering_vars), "\n")
  cat("  - Secondary:", length(suitable_secondary), "\n")
  cat("  Sample size:", nrow(cluster_data_extended), "\n")
  cat("  Suitable secondary variables:\n")
  for(var in suitable_secondary) {
    cat(sprintf("    %s\n", var))
  }
  cat("  Strengths: Behavioral phenotypes, clinical relevance\n")
  cat("  Use for: Enriched phenotype discovery\n")
  
} else {
  cat("\nSTRATEGY B: No secondary variables meet inclusion criteria\n")
  cat("  All secondary variables have >", missing_threshold*100, "% missing data\n")
  cat("  Recommendation: Use Strategy A (core variables only)\n")
  
  cluster_data_extended <- cluster_data_unsupervised
  all_clustering_vars <- existing_clustering_vars
}

# CREATE FINAL CLUSTERING DATASETS
cat("\n=== FINAL CLUSTERING DATASETS ===\n")

# Dataset A: Core variables
cat("DATASET A (Core variables):\n")
cat("  Dimensions:", nrow(cluster_data_unsupervised), "x", ncol(cluster_data_unsupervised), "\n")

# Dataset B: Extended (if different from A)
if(exists("cluster_data_extended") && ncol(cluster_data_extended) > ncol(cluster_data_unsupervised)) {
  cat("DATASET B (Extended):\n")
  cat("  Dimensions:", nrow(cluster_data_extended), "x", ncol(cluster_data_extended), "\n")
  cat("  Sample reduction:", nrow(cluster_data_unsupervised) - nrow(cluster_data_extended), "participants\n")
}

# VALIDATION DATASET PREPARATION
cat("\n=== VALIDATION DATASET PREPARATION ===\n")

# Create validation dataset with outcome variable
validation_data <- final_dataset_imputed %>%
  select(all_of(c(existing_clustering_vars, validation_vars)))

cat("Validation dataset prepared:\n")
cat("  Includes outcome variable for post-hoc analysis\n")
cat("  Same participants as core clustering dataset\n")
cat("  Will receive cluster assignments for validation\n")

# DATA PREPROCESSING CHECK
cat("\n=== DATA PREPROCESSING VERIFICATION ===\n")

# Check data types
numeric_vars_core <- sapply(cluster_data_unsupervised, is.numeric)
cat("Core dataset - Numeric variables:", sum(numeric_vars_core), "/", ncol(cluster_data_unsupervised), "\n")

if(any(!numeric_vars_core)) {
  cat("Non-numeric variables needing encoding:\n")
  non_numeric_core <- names(cluster_data_unsupervised)[!numeric_vars_core]
  for(var in non_numeric_core) {
    unique_vals <- length(unique(cluster_data_unsupervised[[var]]))
    cat(sprintf("  %s (%s): %d unique values\n", var, class(cluster_data_unsupervised[[var]])[1], unique_vals))
  }
}

# Check for scaling needs
cat("\nVariable scaling check (means and SDs):\n")
numeric_vars <- cluster_data_unsupervised[, sapply(cluster_data_unsupervised, is.numeric)]
if(ncol(numeric_vars) > 0) {
  scale_summary <- data.frame(
    variable = names(numeric_vars),
    mean = sapply(numeric_vars, mean, na.rm = TRUE),
    sd = sapply(numeric_vars, sd, na.rm = TRUE)
  )
  
  # Check if scaling is needed (different orders of magnitude)
  max_mean <- max(abs(scale_summary$mean))
  min_mean <- min(abs(scale_summary$mean[scale_summary$mean != 0]))
  scale_ratio <- max_mean / min_mean
  
  if(scale_ratio > 10) {
    cat("⚠️  Variables have different scales - standardization recommended\n")
    cat("   Scale ratio:", round(scale_ratio, 2), "\n")
  } else {
    cat("✓ Variables are reasonably scaled\n")
  }
}

# Save datasets to global environment
assign("cluster_data_unsupervised", cluster_data_unsupervised, envir = .GlobalEnv)
assign("existing_clustering_vars", existing_clustering_vars, envir = .GlobalEnv)
assign("validation_data", validation_data, envir = .GlobalEnv)
assign("adverse_analysis", adverse_analysis, envir = .GlobalEnv)
assign("substance_analysis", substance_analysis, envir = .GlobalEnv)

if(exists("cluster_data_extended") && ncol(cluster_data_extended) > ncol(cluster_data_unsupervised)) {
  assign("cluster_data_extended", cluster_data_extended, envir = .GlobalEnv)
  assign("all_clustering_vars", all_clustering_vars, envir = .GlobalEnv)
  cat("✓ Both core and extended datasets saved\n")
} else {
  cat("✓ Core dataset saved (extended same as core)\n")
}

# ANALYSIS WORKFLOW GUIDANCE
cat("\n=== RECOMMENDED ANALYSIS WORKFLOW ===\n")
cat("1. CLUSTERING PHASE (unsupervised):\n")
cat("   a) Standardize variables if needed\n")
cat("   b) Determine optimal k using elbow/silhouette/gap methods\n")
cat("   c) Apply clustering algorithm (k-means, hierarchical)\n")
cat("   d) Assess cluster stability and interpretation\n")

cat("\n2. VALIDATION PHASE (supervised):\n")
cat("   a) Add cluster assignments to validation_data\n")
cat("   b) Test association: clusters ~ scrn_stopped_bzra\n")
cat("   c) Characterize clusters using all available variables\n")
cat("   d) Clinical interpretation and phenotype naming\n")

cat("\n3. CHARACTERIZATION PHASE:\n")
cat("   a) Describe clusters using excluded secondary variables\n")
cat("   b) Test differences in adverse effects by cluster\n")
cat("   c) Test differences in substance use by cluster\n")
cat("   d) Generate cluster profiles for clinical translation\n")

cat("\n✓ Ready for unsupervised cluster analysis\n")
cat("✓ Outcome variable excluded from clustering\n")
cat("✓ Validation framework prepared\n")

```

