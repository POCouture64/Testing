---
title: "Testing"
author: "POC"
format: html
editor: visual
---

## Testing

I will use this document to work on my SIMOA code since I am having trouble with it currently in the existing format. In this way I can mess around with this code and not be worried about it impacting my original data and now that I know what I want to do for my clusters it is easier for me to manipulate the variables in a manner that will set me up for success later.

## Loading the Data

The section I will use to lead the dataset that I will use for the analysis.

```{r}
#| label: Loading the Data and Libraries
######
# Loading required libraries and data
# In this section I will load all necessary packages and the dataset I want to use and name it "SIMOA" 
# so it is easier to call back on later and i know that this is my original dataset.
######

# Load all required libraries
library(readr)        # For reading CSV files
library(tidyverse)    # For data manipulation (dplyr, ggplot2, etc.)
library(mice)         # For multiple imputation
library(VIM)          # For visualizing missing data
library(naniar)       # For missing data exploration
library(effsize)      # For effect size calculations
library(ggplot2)      # For plotting (part of tidyverse but explicit)

# Load the dataset
SIMOA <- read_csv("SIMOA Report.csv")
#View(SIMOA)
```

## Eligible Participants

The section where I have set out the inclusion criteria to remove people from the dataset that do not meet our criteria.

```{r}
#| label: Eligible Participants
######
# In this section I will filter out those who have indicated they are <65 or that have not answered   
# yes to the question about age category or not answered either question. I will also filter out those 
# who did not select one of the 14 BZRAs listed because we do not want the results to be affected by 
# other sedating medications such as antihistamines or SSRI's.
######

# Original count
n_original <- nrow(SIMOA)

# After age filtering
SIMOA_age_filtered <- SIMOA %>%
  filter(age_cat == 1 | (age_cat == 0 & age >= 65))
n_after_age <- nrow(SIMOA_age_filtered)

# After both filters
SIMOA <- SIMOA_age_filtered %>%
  filter(rowSums(select(., starts_with("c_sp___"))[, 1:14] == 1, na.rm = TRUE) > 0)
n_final <- nrow(SIMOA)

# Report results
cat("Original sample:", n_original, "\n")
cat("After age filtering:", n_after_age, "(removed:", n_original - n_after_age, ")\n")
cat("After c_sp filtering:", n_final, "(removed:", n_after_age - n_final, ")\n")
cat("Total removed:", n_original - n_final, "\n")
```


## Calculating Subscale Scores

The section where I go about calculating the subscale scores for all the measures and ensure that this is properly done and that way I can compare the groups in subscales rather than the full measure and it makes it easier to report.

```{r}
#| label: Subscale Scores
######
# In this section I will get the subscale scores for all the measures I have used. I will also ensure
# that items are appropriately reverse-coded.
# All subscale score coding will be found in this chunk but I have divided them to make them easy to 
# find. I would rather have 1 chunk that way it cuts down on the amount of space being taken up for this step.
######

# First, let's create a working copy
data_personality <- SIMOA

######
# BFI-10 SUBSCALE SCORES
######

# Items to reverse: reserved, find_fault, lazy, relaxed, few_interests
# Formula: reversed_score = 6 - original_score
data_personality <- data_personality %>%
  mutate(
    reserved_rev = 6 - reserved,
    find_fault_rev = 6 - find_fault,
    lazy_rev = 6 - lazy,
    relaxed_rev = 6 - relaxed,
    few_interests_rev = 6 - few_interests
  )

# Verifying Reverse-Coding
data_personality %>%
  select(reserved, reserved_rev, find_fault, find_fault_rev, lazy, lazy_rev, 
         relaxed, relaxed_rev, few_interests, few_interests_rev) %>%
  head(10)

# Verify the math: original + reversed should equal 6
verification_check <- data_personality %>%
  mutate(
    reserved_sum = reserved + reserved_rev,
    find_fault_sum = find_fault + find_fault_rev,
    lazy_sum = lazy + lazy_rev,
    relaxed_sum = relaxed + relaxed_rev,
    few_interests_sum = few_interests + few_interests_rev
  ) %>%
  select(ends_with("_sum"))

cat("BFI-10 Reverse coding verification (all should equal 6):\n")
summary(verification_check)

# Creating personality total scores
data_personality <- data_personality %>%
  mutate(
    # Extraversion: reserved (reversed) + outgoing
    Extraversion = reserved_rev + outgoing,
    
    # Agreeableness: trusting + find_fault (reversed)
    Agreeableness = trusting + find_fault_rev,
    
    # Conscientiousness: lazy (reversed) + thorough
    Conscientiousness = lazy_rev + thorough,
    
    # Neuroticism: relaxed (reversed) + nervous
    Neuroticism = relaxed_rev + nervous,
    
    # Openness: few_interests (reversed) + imagination
    Openness = few_interests_rev + imagination
  )

######
# SURPS SUBSCALE SCORES
######

# First, reverse code SURPS Hopelessness items (all except surps17)
# Formula for 1-4 scale: reversed_score = 5 - original_score
data_personality <- data_personality %>%
  mutate(
    surps1_rev = 5 - surps1,
    surps4_rev = 5 - surps4,
    surps7_rev = 5 - surps7,
    surps13_rev = 5 - surps13,
    surps20_rev = 5 - surps20,
    surps23_rev = 5 - surps23
    # Note: surps17 is NOT reversed
  )

# Quick verification - all sums should equal 5
cat("SURPS reverse coding verification (all should equal 5):\n")
print(unique(data_personality$surps1 + data_personality$surps1_rev))
print(unique(data_personality$surps4 + data_personality$surps4_rev))
print(unique(data_personality$surps7 + data_personality$surps7_rev))

# Create SURPS total scores
data_personality <- data_personality %>%
  mutate(
    # Impulsivity: surps2, surps5, surps11, surps15, surps22
    SURPS_Impulsivity = surps2 + surps5 + surps11 + surps15 + surps22,
    
    # Sensation Seeking: surps3, surps6, surps9, surps12, surps16, surps19
    SURPS_Sensation_Seeking = surps3 + surps6 + surps9 + surps12 + surps16 + surps19,
    
    # Hopelessness: surps1(rev), surps4(rev), surps7(rev), surps13(rev), surps17, surps20(rev), surps23(rev)
    SURPS_Hopelessness = surps1_rev + surps4_rev + surps7_rev + surps13_rev + surps17 + surps20_rev + surps23_rev,
    
    # Anxiety Sensitivity: surps8, surps10, surps14, surps18, surps21
    SURPS_Anxiety_Sensitivity = surps8 + surps10 + surps14 + surps18 + surps21
  )

######
# DBAS SUBSCALE SCORES
######

# Response scale: 0-10 (0 = Strongly Disagree, 10 = Strongly Agree)
# No reverse coding needed for DBAS-16
data_personality <- data_personality %>%
  mutate(
    # Expectations subscale (2 items)
    DBAS_Expectations = rowMeans(select(., dbas1, dbas_2), na.rm = TRUE),
    
    # Medications subscale (3 items) 
    DBAS_Medications = rowMeans(select(., dbas_6, dbas_13, dbas_15), na.rm = TRUE),
    
    # Worry/Helplessness subscale (6 items)
    DBAS_Worry_Helplessness = rowMeans(select(., dbas_3, dbas_4, dbas_8, dbas_10, dbas_11, dbas_14), na.rm = TRUE),
    
    # Consequences subscale (5 items)
    DBAS_Consequences = rowMeans(select(., dbas_5, dbas_7, dbas_9, dbas_12, dbas_16), na.rm = TRUE)
  )

# DBAS verification
cat("DBAS-16 Subscale Summary:\n")
data_personality %>%
  select(DBAS_Expectations, DBAS_Medications, DBAS_Worry_Helplessness, DBAS_Consequences) %>%
  summary()

######
# CISS SUBSCALE SCORES
######

data_personality <- data_personality %>%
  mutate(
    # Avoidance Style: ciss1, ciss4, ciss7, ciss9, ciss15, ciss18, ciss21
    CISS_Avoidance_Style = ciss1 + ciss4 + ciss7 + ciss9 + ciss15 + ciss18 + ciss21,
    
    # Task Style: ciss2, ciss6, ciss8, ciss11, ciss13, ciss16, ciss19
    CISS_Task_Style = ciss2 + ciss6 + ciss8 + ciss11 + ciss13 + ciss16 + ciss19,
    
    # Emotional Style: ciss3, ciss5, ciss10, ciss12, ciss14, ciss17, ciss20
    CISS_Emotional_Style = ciss3 + ciss5 + ciss10 + ciss12 + ciss14 + ciss17 + ciss20
  )

# Calculate DBAS total score (sum of all subscales)
data_personality <- data_personality %>%
  mutate(
    # Total DBAS score (sum of all 4 subscales)
    dbas_score = DBAS_Expectations + DBAS_Medications + DBAS_Worry_Helplessness + DBAS_Consequences
  )

# Verification for DBAS total score
cat("DBAS Total Score Summary:\n")
summary(data_personality$dbas_score)
cat("Expected range: 0-10 (average of subscales) or sum of raw items\n\n")
```


## MICE Parameters Optimization

This section examines the data to determine the ideal number of iterations and imputations I should use on my code to ensure it is the ideal number.

```{r}
#| label: MICE Parameters Optimization
######
# Determine optimal number of imputations and iterations for MICE
######

# Quick initial analysis to estimate required imputations
# Rule of thumb: number of imputations should be at least equal to percentage of missing cases

# Calculate overall missingness
initial_dataset <- data_personality %>%
  select(all_of(c(
    "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", "DBAS_Medications",
    "Extraversion", "Agreeableness", "Conscientiousness", "Neuroticism", "Openness",
    "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", "SURPS_Anxiety_Sensitivity",
    "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
    "osss_3_score", "phq2_score", "age", "sex", "gender", "prov_terr", 
    "education", "employment", "driving_freq", "income"
  )))

# Calculate percentage of incomplete cases
incomplete_cases <- sum(!complete.cases(initial_dataset))
total_cases <- nrow(initial_dataset)
percent_incomplete <- round((incomplete_cases / total_cases) * 100, 1)

cat("=== MICE PARAMETER OPTIMIZATION ===\n")
cat("Total cases:", total_cases, "\n")
cat("Complete cases:", total_cases - incomplete_cases, "\n") 
cat("Incomplete cases:", incomplete_cases, "\n")
cat("Percentage incomplete:", percent_incomplete, "%\n\n")

# Recommend number of imputations
recommended_m <- max(5, ceiling(percent_incomplete))
if(recommended_m > 20) recommended_m <- 20  # Cap at reasonable maximum

cat("RECOMMENDATIONS:\n")
cat("Minimum imputations (m):", max(5, percent_incomplete), "\n")
cat("Recommended imputations (m):", recommended_m, "\n\n")

# Test convergence with different iteration numbers
cat("Testing convergence with different iteration numbers...\n")

# Convert categorical variables to factors for testing
test_dataset <- initial_dataset
categorical_vars <- c("sex", "gender", "prov_terr", "education", "employment", "driving_freq", "income")

for(var in categorical_vars) {
  if(var %in% names(test_dataset)) {
    test_dataset[[var]] <- as.factor(test_dataset[[var]])
  }
}

# Test with 5 iterations (quick test)
set.seed(123)
mice_test_5 <- mice(test_dataset, m = 3, maxit = 5, printFlag = FALSE)

# Test with 10 iterations  
set.seed(123)
mice_test_10 <- mice(test_dataset, m = 3, maxit = 10, printFlag = FALSE)

# Test with 20 iterations
set.seed(123)
mice_test_20 <- mice(test_dataset, m = 3, maxit = 20, printFlag = FALSE)

# Plot convergence (if you want to see plots, uncomment these lines)
plot(mice_test_5)
plot(mice_test_10) 
plot(mice_test_20)

# Check convergence statistics
cat("Convergence check complete.\n")
cat("Recommended iterations (maxit): 10-20 (check plots if convergence issues)\n\n")

cat("FINAL RECOMMENDATIONS:\n")
cat("Use m =", recommended_m, "imputations\n")
cat("Use maxit = 10 iterations (increase to 20 if convergence issues)\n")
cat("Monitor convergence plots if you notice unstable results\n\n")
```


## Missing Data Analysis

This section examines the missing data patterns before doing the multiple imputation to see if any special attention or statistics are required.

```{r}
#| label: Missing Data Analysis
######
# Examine missing data patterns before imputation
######

# Select variables for analysis
analysis_vars <- c(
  # DBAS scales (5 variables - including total score)
  "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", "DBAS_Medications", "dbas_score",
  # Personality scales (5 variables)
  "Extraversion", "Agreeableness", "Conscientiousness", "Neuroticism", "Openness",
  # SURPS scales (4 variables)
  "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", "SURPS_Anxiety_Sensitivity",
  # CISS scales (3 variables)
  "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
  # Additional variables (2 variables)
  "osss_3_score", "phq2_score",
  # Demographic variables (8 variables)
  "age", "sex", "gender", "prov_terr", "education", "employment", "driving_freq", "income"
  # Outcome variable
  #"scrn_stopped_bzra"
)

# I removed scrn_stopped_bzra because it is the outcome variable and should not be imputed because it may create artificial relationships, this is the prediction/analysis variable so imputing it would be circular reasoning, CI and other stats may be incorrect if the outcome is imputed.


# Create dataset with selected variables
final_dataset <- data_personality %>%
  select(all_of(analysis_vars))

# Examine missing data patterns
cat("=== MISSING DATA ANALYSIS ===\n")
cat("Total sample size:", nrow(final_dataset), "\n\n")

# Missing data summary
missing_summary <- final_dataset %>%
  summarise_all(~sum(is.na(.))) %>%
  gather(variable, missing_count) %>%
  mutate(missing_percent = round((missing_count / nrow(final_dataset)) * 100, 1)) %>%
  arrange(desc(missing_count))

print("Missing data by variable:")
print(missing_summary)

# Check missing data patterns
cat("\nMissing data patterns:\n")
md.pattern(final_dataset, rotate.names = TRUE)

# Visualize missing data (optional)
VIM::aggr(final_dataset, col = c('navyblue','red'), numbers = TRUE, sortVars = TRUE)
```


## Multiple Imputation

This section applies the findings from the previous 2 chunks to fill in the missing data and then reports the final dataset size.

```{r}
#| label: Multiple Imputation
######
# Apply MICE imputation for missing data
# Only including cases with valid scrn_stopped_bzra responses
######

# Filter to only include cases where scrn_stopped_bzra is not NA
cat("=== FILTERING FOR COMPLETE OUTCOME DATA ===\n")
cat("Original dataset size:", nrow(final_dataset), "\n")
cat("Cases with missing scrn_stopped_bzra:", sum(is.na(data_personality$scrn_stopped_bzra[1:nrow(final_dataset)])), "\n")

# Create indices for cases with valid outcome data
valid_outcome_indices <- which(!is.na(data_personality$scrn_stopped_bzra[1:nrow(final_dataset)]))

# Filter final_dataset to only include cases with valid outcome
final_dataset <- final_dataset[valid_outcome_indices, ]

cat("Filtered dataset size:", nrow(final_dataset), "\n")
cat("Cases removed due to missing outcome:", length(valid_outcome_indices) - nrow(final_dataset) + (nrow(data_personality) - length(valid_outcome_indices)), "\n")

# Set seed for reproducibility
set.seed(123)

# Convert categorical variables to factors
categorical_vars <- c("sex", "gender", "prov_terr", "education", "employment", "driving_freq", "income")
for(var in categorical_vars) {
  if(var %in% names(final_dataset)) {
    if(!is.factor(final_dataset[[var]])) {
      final_dataset[[var]] <- as.factor(final_dataset[[var]])
      cat(paste("Converted", var, "to factor\n"))
    }
  }
}

# Check if we have complete cases for comparison
complete_cases <- sum(complete.cases(final_dataset))
cat("Complete cases before imputation:", complete_cases, "out of", nrow(final_dataset), "\n")

# Apply MICE imputation
cat("\n=== RUNNING MICE IMPUTATION ===\n")
mice_result <- mice(final_dataset, m = 5, method = 'pmm', printFlag = FALSE, seed = 123)

# Get the completed dataset (using the first imputation)
final_dataset_imputed <- complete(mice_result, 1)

# Verify imputation worked
cat("\n=== IMPUTATION VERIFICATION ===\n")
cat("Missing values after MICE:\n")
print(sapply(final_dataset_imputed, function(x) sum(is.na(x))))

cat("\nFinal sample size:", nrow(final_dataset_imputed), "\n")

# Adding the outcome variable back to the imputed dataset for analysis
# Use the valid indices to get the corresponding outcome values
final_dataset_imputed$scrn_stopped_bzra <- data_personality$scrn_stopped_bzra[valid_outcome_indices]

# Verify no missing values in outcome
cat("Missing values in outcome variable:", sum(is.na(final_dataset_imputed$scrn_stopped_bzra)), "\n")
cat("Added outcome variable back to dataset for analysis\n")

# Final verification
cat("\n=== FINAL DATASET SUMMARY ===\n")
cat("Total cases in final imputed dataset:", nrow(final_dataset_imputed), "\n")
cat("Outcome variable distribution:\n")
print(table(final_dataset_imputed$scrn_stopped_bzra, useNA = "ifany"))
```


## Secondary Variables

This section adds variables about adverse effects, dependence, negative daytime experiences, substance use, sleep-related substance use.

These variables could not be imputed because they are not MAR and since they are MNAR multiple imputation is not ideal to analyze the missingness.

```{r}
#| label: Secondary Variable Code
######
# Add adverse effects and substance use variables back to imputed dataset
# These variables are not imputed due to MNAR patterns but kept for secondary analyses
######
cat("=== ADDING SECONDARY VARIABLES FOR CLUSTER ANALYSIS ===\n")

# Define all secondary variables we want to add
secondary_vars_to_add <- c(
  # Adverse effects - current users
  "side_effects_1", "side_effects_2", "side_effects_3", "side_effects_4",
  "safety_1", "safety_2", "safety_3", "safety_4", "adls_1", "adls_2", 
  "dependence_1", "dependence_2", "dependence_3",
  # Adverse effects - past users (v2 versions)
  "side_effects_1_v2", "side_effects_2_v2", "side_effects_3_v2", "side_effects_4_v2",
  "safety_1_v2", "safety_2_v2", "safety_3_v2", "safety_4_v2", "adls_1_v2", "adls_2_v2",
  "dependence_1_v2", "dependence_2_v2", "dependence_3_v2",
  # Substance use variables
  "med_quant", "op_use", "can_use", "alc_use_wmn", "alc_use_men",
  "alc_sleep", "can_sleep", "melatonin_use", "op_sleep", "quet_use", "traz_use", "otc_use"
)

# Check which variables exist in original dataset
existing_secondary_vars <- secondary_vars_to_add[secondary_vars_to_add %in% names(data_personality)]

cat("Secondary variables found in data_personality:", length(existing_secondary_vars), "\n")
if(length(existing_secondary_vars) > 0) {
  cat("Variables found:\n")
  print(existing_secondary_vars)
}

# Add variables back to imputed dataset using the same indexing as before
if(length(existing_secondary_vars) > 0) {
  cat("\n=== ADDING VARIABLES TO IMPUTED DATASET ===\n")
  
  # Use the same valid_outcome_indices from the multiple imputation step
  for(var in existing_secondary_vars) {
    # Get the source data using the same indices as the imputed dataset
    source_data <- data_personality[[var]][valid_outcome_indices]
    
    # Add to imputed dataset
    final_dataset_imputed[[var]] <- source_data
    
    missing_count <- sum(is.na(source_data))
    non_missing <- sum(!is.na(source_data))
    cat(sprintf("Added %s: %d non-missing, %d missing\n", var, non_missing, missing_count))
  }
} else {
  cat("No secondary variables found to add\n")
}

# COMBINE GENDER-SPECIFIC ALCOHOL VARIABLES
cat("\n=== COMBINING GENDER-SPECIFIC ALCOHOL VARIABLES ===\n")
if("alc_use_wmn" %in% names(final_dataset_imputed) && "alc_use_men" %in% names(final_dataset_imputed)) {
  # Create combined alcohol variable based on sex
  # sex = 1 shows alc_use_wmn, sex = 2 shows alc_use_men
  final_dataset_imputed$alc_use_combined <- ifelse(
    final_dataset_imputed$sex == 1, 
    final_dataset_imputed$alc_use_wmn,
    final_dataset_imputed$alc_use_men
  )
  
  # Check the combination worked
  wmn_data_count <- sum(!is.na(final_dataset_imputed$alc_use_wmn))
  men_data_count <- sum(!is.na(final_dataset_imputed$alc_use_men))
  combined_data_count <- sum(!is.na(final_dataset_imputed$alc_use_combined))
  
  cat(sprintf("Original alc_use_wmn: %d non-missing\n", wmn_data_count))
  cat(sprintf("Original alc_use_men: %d non-missing\n", men_data_count))
  cat(sprintf("Combined alc_use_combined: %d non-missing\n", combined_data_count))
  
  # Remove the original gender-specific variables
  final_dataset_imputed$alc_use_wmn <- NULL
  final_dataset_imputed$alc_use_men <- NULL
  
  cat("✓ Gender-specific alcohol variables combined and originals removed\n")
} else {
  cat("Gender-specific alcohol variables not found\n")
}

# Define adverse effects variable pairs for combination
adverse_var_pairs <- list(
  side_effects_1_combined = c("side_effects_1", "side_effects_1_v2"),
  side_effects_2_combined = c("side_effects_2", "side_effects_2_v2"),
  side_effects_3_combined = c("side_effects_3", "side_effects_3_v2"),
  side_effects_4_combined = c("side_effects_4", "side_effects_4_v2"),
  safety_1_combined = c("safety_1", "safety_1_v2"),
  safety_2_combined = c("safety_2", "safety_2_v2"),
  safety_3_combined = c("safety_3", "safety_3_v2"),
  safety_4_combined = c("safety_4", "safety_4_v2"),
  adls_1_combined = c("adls_1", "adls_1_v2"),
  adls_2_combined = c("adls_2", "adls_2_v2"),
  dependence_1_combined = c("dependence_1", "dependence_1_v2"),
  dependence_2_combined = c("dependence_2", "dependence_2_v2"),
  dependence_3_combined = c("dependence_3", "dependence_3_v2")
)

cat("\n=== COMBINING ADVERSE EFFECTS VARIABLES ===\n")

# Track successfully combined variables
combined_adverse_vars_cluster <- character(0)

# Process each adverse effects variable pair
for(combined_name in names(adverse_var_pairs)) {
  current_var <- adverse_var_pairs[[combined_name]][1]
  past_var <- adverse_var_pairs[[combined_name]][2]
  
  cat("Processing", combined_name, "...\n")
  
  current_exists <- current_var %in% names(final_dataset_imputed)
  past_exists <- past_var %in% names(final_dataset_imputed)
  
  if(current_exists && past_exists) {
    # Get the data
    current_data <- final_dataset_imputed[[current_var]]
    past_data <- final_dataset_imputed[[past_var]]
    outcome_data <- final_dataset_imputed$scrn_stopped_bzra
    
    # Create combined variable
    combined_data <- rep(NA, nrow(final_dataset_imputed))
    
    # For current users (scrn_stopped_bzra == 0), use current version
    current_user_indices <- which(outcome_data == 0)
    if(length(current_user_indices) > 0) {
      combined_data[current_user_indices] <- current_data[current_user_indices]
    }
    
    # For past users (scrn_stopped_bzra == 1), use past version  
    past_user_indices <- which(outcome_data == 1)
    if(length(past_user_indices) > 0) {
      combined_data[past_user_indices] <- past_data[past_user_indices]
    }
    
    # Add to dataset
    final_dataset_imputed[[combined_name]] <- combined_data
    combined_adverse_vars_cluster <- c(combined_adverse_vars_cluster, combined_name)
    
    # Remove original versions to avoid confusion
    final_dataset_imputed[[current_var]] <- NULL
    final_dataset_imputed[[past_var]] <- NULL
    
    missing_count <- sum(is.na(combined_data))
    non_missing <- sum(!is.na(combined_data))
    cat(sprintf("✓ Created %s: %d non-missing, %d missing\n", combined_name, non_missing, missing_count))
    
  } else if(current_exists) {
    # Only current version exists
    final_dataset_imputed[[combined_name]] <- final_dataset_imputed[[current_var]]
    final_dataset_imputed[[current_var]] <- NULL
    combined_adverse_vars_cluster <- c(combined_adverse_vars_cluster, combined_name)
    cat(sprintf("✓ Used current version for %s\n", combined_name))
    
  } else if(past_exists) {
    # Only past version exists
    final_dataset_imputed[[combined_name]] <- final_dataset_imputed[[past_var]]
    final_dataset_imputed[[past_var]] <- NULL
    combined_adverse_vars_cluster <- c(combined_adverse_vars_cluster, combined_name)
    cat(sprintf("✓ Used past version for %s\n", combined_name))
    
  } else {
    cat(sprintf("✗ Neither version exists for %s\n", combined_name))
  }
}

# Get substance use variables (updated to include combined alcohol variable)
substance_vars_cluster <- names(final_dataset_imputed)[grepl("alc_|can_|op_|med_|melatonin|quet|traz|otc", names(final_dataset_imputed))]

cat("\n=== CLUSTER ANALYSIS VARIABLES SUMMARY ===\n")
cat("Combined adverse effects variables:", length(combined_adverse_vars_cluster), "\n")
if(length(combined_adverse_vars_cluster) > 0) {
  cat("Adverse effects variables:\n")
  for(var in combined_adverse_vars_cluster) {
    missing_count <- sum(is.na(final_dataset_imputed[[var]]))
    non_missing <- sum(!is.na(final_dataset_imputed[[var]]))
    cat(sprintf("  %s: %d non-missing, %d missing\n", var, non_missing, missing_count))
  }
}

cat("\nSubstance use variables:", length(substance_vars_cluster), "\n")
if(length(substance_vars_cluster) > 0) {
  cat("Substance use variables:\n")
  for(var in substance_vars_cluster) {
    missing_count <- sum(is.na(final_dataset_imputed[[var]]))
    non_missing <- sum(!is.na(final_dataset_imputed[[var]]))
    cat(sprintf("  %s: %d non-missing, %d missing\n", var, non_missing, missing_count))
  }
}

# Create cluster analysis dataset
cat("\n=== CREATING CLUSTER ANALYSIS DATASET ===\n")

# Core variables for cluster analysis (imputed, so complete)
core_cluster_vars <- c(
  # DBAS scales
  "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", "DBAS_Medications",
  # Personality
  "Extraversion", "Agreeableness", "Conscientiousness", "Neuroticism", "Openness",
  # SURPS
  "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", "SURPS_Anxiety_Sensitivity",
  # CISS
  "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
  # Other scales
  "osss_3_score", "phq2_score",
  # Demographics
  "age", "sex",
  # Outcome
  "scrn_stopped_bzra"
)

# Check which core variables exist
existing_core_cluster <- core_cluster_vars[core_cluster_vars %in% names(final_dataset_imputed)]

# Combine all variables for cluster analysis
all_cluster_vars <- c(existing_core_cluster, combined_adverse_vars_cluster, substance_vars_cluster)

# Create cluster analysis dataset with complete cases only for secondary variables
cluster_analysis_data <- final_dataset_imputed %>%
  select(all_of(all_cluster_vars)) %>%
  # Keep all cases for core variables (they're imputed), but require complete cases for secondary variables
  filter(if(length(c(combined_adverse_vars_cluster, substance_vars_cluster)) > 0) {
    complete.cases(select(., all_of(c(combined_adverse_vars_cluster, substance_vars_cluster))))
  } else {
    TRUE
  })

cat("Cluster analysis dataset created:\n")
cat("Total variables:", length(all_cluster_vars), "\n")
cat("- Core variables (imputed):", length(existing_core_cluster), "\n")
cat("- Adverse effects variables:", length(combined_adverse_vars_cluster), "\n") 
cat("- Substance use variables:", length(substance_vars_cluster), "\n")
cat("Complete cases:", nrow(cluster_analysis_data), "out of", nrow(final_dataset_imputed), "total\n")

# Save datasets to global environment
assign("final_dataset_imputed", final_dataset_imputed, envir = .GlobalEnv)
assign("cluster_analysis_data", cluster_analysis_data, envir = .GlobalEnv)
assign("combined_adverse_vars_cluster", combined_adverse_vars_cluster, envir = .GlobalEnv)
assign("substance_vars_cluster", substance_vars_cluster, envir = .GlobalEnv)

cat("\n✓ All variables prepared for cluster analysis\n")
cat("✓ final_dataset_imputed updated with combined variables\n")
cat("✓ cluster_analysis_data ready for cluster analysis\n")

# Final verification
cat("\nFinal dataset dimensions:", nrow(final_dataset_imputed), "x", ncol(final_dataset_imputed), "\n")
cat("Variables available for clustering:\n")
if(length(combined_adverse_vars_cluster) > 0) {
  cat("- Adverse effects (combined):", paste(head(combined_adverse_vars_cluster, 5), collapse = ", "))
  if(length(combined_adverse_vars_cluster) > 5) cat("... and", length(combined_adverse_vars_cluster) - 5, "more")
  cat("\n")
}
if(length(substance_vars_cluster) > 0) {
  cat("- Substance use:", paste(head(substance_vars_cluster, 5), collapse = ", "))
  if(length(substance_vars_cluster) > 5) cat("... and", length(substance_vars_cluster) - 5, "more")
  cat("\n")
}
```


## Data Preperation

The section where I will change some of the variables to different groupings. I will change the regional groupings to regions of the country rather than each province, I will change the educational groupings to simply <High School or Trade/Uni, and I will change employment to Full/Part Time Work or Not Employed/Retired.

```{r}
#| label: Data Preparation for Analysis 
######
# Prepare data with grouped variables
# Variables already detected in previous step
######

library(dplyr)

cat("=== DATA PREPARATION ===\n")
cat("Dataset dimensions:", nrow(final_dataset_imputed), "rows,", ncol(final_dataset_imputed), "columns\n")

# Variables are already set from previous step, just verify
cat("Using variables from secondary analysis step:\n")
cat("- Combined adverse effects variables:", length(combined_adverse_vars), "\n")
cat("- Substance use variables:", length(substance_vars), "\n")
cat("- Final numeric variables:", length(final_numeric_vars), "\n")

# --- Regional groupings ---
if("prov_terr" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$prov_terr_region <- case_when(
    final_dataset_imputed$prov_terr %in% c(1, 2, 3, 12) ~ "Prairies",
    final_dataset_imputed$prov_terr %in% c(9, 11) ~ "Central Canada", 
    final_dataset_imputed$prov_terr %in% c(4, 5, 7, 10) ~ "Atlantic Canada",
    final_dataset_imputed$prov_terr %in% c(6, 8, 13) ~ "Territories",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$prov_terr_region <- factor(final_dataset_imputed$prov_terr_region,
                                                   levels = c("Prairies", "Central Canada", 
                                                              "Atlantic Canada", "Territories"))
  cat("✓ Created regional groupings\n")
}

# --- Education groupings ---
if("education" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$education_level <- case_when(
    final_dataset_imputed$education %in% c(1, 2, 3) ~ "High School or Less",
    final_dataset_imputed$education %in% c(4, 5) ~ "Trade School/University",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$education_level <- factor(final_dataset_imputed$education_level,
                                                  levels = c("High School or Less", "Trade School/University"))
  cat("✓ Created education level groupings\n")
}

# --- Employment groupings ---
if("employment" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$employment_status <- case_when(
    final_dataset_imputed$employment %in% c(0, 3, 4) ~ "Retired/Not in Workforce",
    final_dataset_imputed$employment %in% c(1, 2) ~ "Full- or Part-Time",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$employment_status <- factor(final_dataset_imputed$employment_status,
                                                    levels = c("Full- or Part-Time", "Retired/Not in Workforce"))
  cat("✓ Created employment status groupings\n")
}

# Verify outcome variable is properly coded
if("scrn_stopped_bzra" %in% names(final_dataset_imputed)) {
  cat("\n✓ Outcome variable verification:\n")
  cat("Missing values in scrn_stopped_bzra:", sum(is.na(final_dataset_imputed$scrn_stopped_bzra)), "\n")
  cat("Distribution of scrn_stopped_bzra:\n")
  print(table(final_dataset_imputed$scrn_stopped_bzra, useNA = "ifany"))
}

cat("\nData preparation complete!\n")
```


## Entire Group Descriptives

This section of the code will present all the descriptive statistics for the entire group with the variables about adverse effects, dependence, negative daytime experiences, substance use, sleep-related substance use added to the core personality and demographics data. 

```{r}
#| label: Entire Group Descriptives
######
# This chunk describes the entire sample (no grouping by BZRA status).
# It separates variables into: 
#   1. Continuous
#   2. Ordinal (frequency/attitudes)
#   3. Categorical (demographics)
######

library(dplyr)

cat("=== ENTIRE SAMPLE DESCRIPTIVE STATISTICS ===\n")
cat("Sample size:", nrow(final_dataset_imputed), "\n")

# Identify numeric variables
numeric_vars <- names(final_dataset_imputed)[sapply(final_dataset_imputed, is.numeric)]
# Remove categorical numeric variables (Likert/radio) from numeric summary
categorical_numeric_vars <- c(
  "op_use", "can_use", "alc_sleep", "can_sleep", "melatonin_use", "op_sleep",
  "quet_use", "traz_use", "otc_use",
  "side_effects_1_combined", "side_effects_2_combined", "side_effects_3_combined", "side_effects_4_combined",
  "safety_1_combined", "safety_2_combined", "safety_3_combined", "safety_4_combined",
  "adls_1_combined", "adls_2_combined",
  "dependence_1_combined", "dependence_2_combined", "dependence_3_combined",
  "alc_use_combined"
)
numeric_vars <- setdiff(numeric_vars, categorical_numeric_vars)

# Numeric variables summary
if(length(numeric_vars) > 0) {
  cat("\nNUMERIC VARIABLES:\n")
  for(var in numeric_vars) {
    x <- final_dataset_imputed[[var]]
    cat(var, "-> Mean:", round(mean(x, na.rm=TRUE),2),
        "SD:", round(sd(x, na.rm=TRUE),2),
        "Min:", round(min(x, na.rm=TRUE),2),
        "Max:", round(max(x, na.rm=TRUE),2), "\n")
  }
}

# Automatically identify categorical variables
auto_categorical_vars <- names(final_dataset_imputed)[sapply(final_dataset_imputed, function(x) {
  is.factor(x) || (is.numeric(x) && length(unique(x[!is.na(x)])) <= 6)
})]
# Remove numeric variables
auto_categorical_vars <- setdiff(auto_categorical_vars, numeric_vars)

# Categorical variables summary
cat("\nCATEGORICAL VARIABLES:\n")
for(var in auto_categorical_vars) {
  if(var %in% names(final_dataset_imputed)) {
    cat("\n", var, ":\n")
    counts <- table(final_dataset_imputed[[var]], useNA = "ifany")
    perc <- round(prop.table(counts) * 100, 1)
    for(i in seq_along(counts)) {
      cat("  ", names(counts)[i], ": ", counts[i], " (", perc[i], "%)\n", sep = "")
    }
  }
}

# === ALCOHOL USE DESCRIPTIVES (separate by sex using alc_use_combined) ===
cat("\n--- ALCOHOL USE (separate by sex using alc_use_combined) ---\n")

cat("\nAlcohol Use - Women:\n")
if("alc_use_combined" %in% names(final_dataset_imputed)) {
  counts_w <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 1], useNA = "ifany")
  perc_w <- round(prop.table(counts_w) * 100, 1)
  for(i in seq_along(counts_w)) {
    cat("  ", names(counts_w)[i], ": ", counts_w[i], " (", perc_w[i], "%)\n", sep = "")
  }
}

cat("\nAlcohol Use - Men:\n")
if("alc_use_combined" %in% names(final_dataset_imputed)) {
  counts_m <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 2], useNA = "ifany")
  perc_m <- round(prop.table(counts_m) * 100, 1)
  for(i in seq_along(counts_m)) {
    cat("  ", names(counts_m)[i], ": ", counts_m[i], " (", perc_m[i], "%)\n", sep = "")
  }
}

cat("\n=== DESCRIPTIVES COMPLETE ===\n")
```


## Group Comparison Descriptives

This section will split the groups based on their answer to scrn_stopped_bzra.

```{r}
#| label: Descriptives by BZRA status with effect sizes
#######
# Descriptive statistics for the entire sample, divided by BZRA status
# (scrn_stopped_bzra), including numeric effect sizes (Cohen's d)
#######
library(dplyr)
library(effsize)
cat("=== DESCRIPTIVE STATISTICS BY BZRA STATUS ===\n")
cat("Total sample size:", nrow(final_dataset_imputed), "\n")

# Create group labels using the correct factor levels
current_users <- final_dataset_imputed$scrn_stopped_bzra == "Current Users (0)"
past_users <- final_dataset_imputed$scrn_stopped_bzra == "Past Users (1)"

cat("Current Users (0):", sum(current_users, na.rm = TRUE), "\n")
cat("Past Users (1):", sum(past_users, na.rm = TRUE), "\n\n")

# Identify numeric variables
numeric_vars <- names(final_dataset_imputed)[sapply(final_dataset_imputed, is.numeric)]

# Remove categorical numeric variables (Likert/radio) from numeric summary
categorical_numeric_vars <- c(
  "op_use", "can_use", "alc_sleep", "can_sleep", "melatonin_use", "op_sleep",
  "quet_use", "traz_use", "otc_use",
  "side_effects_1_combined", "side_effects_2_combined", "side_effects_3_combined", "side_effects_4_combined",
  "safety_1_combined", "safety_2_combined", "safety_3_combined", "safety_4_combined",
  "adls_1_combined", "adls_2_combined",
  "dependence_1_combined", "dependence_2_combined", "dependence_3_combined",
  "alc_use_combined"
)
numeric_vars <- setdiff(numeric_vars, categorical_numeric_vars)

# Numeric variables summary by group with effect sizes
if(length(numeric_vars) > 0) {
  cat("=== NUMERIC VARIABLES ===\n")
  for(var in numeric_vars) {
    cat("\n", var, ":\n")
    
    # Current users
    x_current <- final_dataset_imputed[[var]][current_users]
    x_current_clean <- x_current[!is.na(x_current)]
    cat("  Current Users -> Mean:", round(mean(x_current, na.rm=TRUE),2),
        "SD:", round(sd(x_current, na.rm=TRUE),2),
        "Min:", round(min(x_current, na.rm=TRUE),2),
        "Max:", round(max(x_current, na.rm=TRUE),2), "\n")
    
    # Past users
    x_past <- final_dataset_imputed[[var]][past_users]
    x_past_clean <- x_past[!is.na(x_past)]
    cat("  Past Users    -> Mean:", round(mean(x_past, na.rm=TRUE),2),
        "SD:", round(sd(x_past, na.rm=TRUE),2),
        "Min:", round(min(x_past, na.rm=TRUE),2),
        "Max:", round(max(x_past, na.rm=TRUE),2), "\n")
    
    # Effect size and significance test
    if(length(x_current_clean) > 0 & length(x_past_clean) > 0) {
      # Cohen's d
      cohens_d <- tryCatch({
        d_result <- cohen.d(x_past_clean, x_current_clean)
        round(d_result$estimate, 3)
      }, error = function(e) NA)
      
      # t-test
      t_test <- tryCatch({
        t.test(x_past_clean, x_current_clean)
      }, error = function(e) NULL)
      
      p_val <- if(!is.null(t_test)) {
        if(t_test$p.value < 0.001) "< 0.001" else round(t_test$p.value, 4)
      } else NA
      
      cat("  Effect size: Cohen's d =", cohens_d, ", p-value =", p_val, "\n")
    }
  }
}

# Automatically identify categorical variables
auto_categorical_vars <- names(final_dataset_imputed)[sapply(final_dataset_imputed, function(x) {
  is.factor(x) || (is.numeric(x) && length(unique(x[!is.na(x)])) <= 6)
})]

# Remove numeric variables
auto_categorical_vars <- setdiff(auto_categorical_vars, numeric_vars)

# Categorical variables summary by group with effect sizes
cat("\n=== CATEGORICAL VARIABLES ===\n")
for(var in auto_categorical_vars) {
  if(var %in% names(final_dataset_imputed)) {
    cat("\n", var, ":\n")
    
    # Current users
    cat("  Current Users:\n")
    counts_current <- table(final_dataset_imputed[[var]][current_users], useNA = "ifany")
    perc_current <- round(prop.table(counts_current) * 100, 1)
    for(i in seq_along(counts_current)) {
      cat("    ", names(counts_current)[i], ": ", counts_current[i], " (", perc_current[i], "%)\n", sep = "")
    }
    
    # Past users
    cat("  Past Users:\n")
    counts_past <- table(final_dataset_imputed[[var]][past_users], useNA = "ifany")
    perc_past <- round(prop.table(counts_past) * 100, 1)
    for(i in seq_along(counts_past)) {
      cat("    ", names(counts_past)[i], ": ", counts_past[i], " (", perc_past[i], "%)\n", sep = "")
    }
    
    # Effect size for categorical variables
    if(length(counts_current) > 0 & length(counts_past) > 0) {
      # Create contingency table
      cont_table <- tryCatch({
        table(final_dataset_imputed[[var]], final_dataset_imputed$scrn_stopped_bzra)
      }, error = function(e) NULL)
      
      if(!is.null(cont_table) && sum(cont_table) > 0) {
        # Chi-square test
        chi_result <- tryCatch({
          suppressWarnings(chisq.test(cont_table))
        }, error = function(e) NULL)
        
        if(!is.null(chi_result)) {
          p_val <- if(!is.na(chi_result$p.value) && chi_result$p.value < 0.001) {
            "< 0.001" 
          } else if(!is.na(chi_result$p.value)) {
            round(chi_result$p.value, 4)
          } else {
            "NA (insufficient data)"
          }
          
          # Cramér's V (effect size for categorical variables)
          if(!is.na(chi_result$statistic)) {
            cramers_v <- sqrt(chi_result$statistic / (sum(cont_table) * (min(dim(cont_table)) - 1)))
            cat("  Effect size: Cramér's V =", round(cramers_v, 3), ", p-value =", p_val, "\n")
          } else {
            cat("  Effect size: Cannot calculate - insufficient data\n")
          }
        }
      }
    }
  }
}

# === ALCOHOL USE DESCRIPTIVES (separate by sex and BZRA status) ===
cat("\n=== ALCOHOL USE BY SEX AND BZRA STATUS ===\n")

if("alc_use_combined" %in% names(final_dataset_imputed)) {
  # Women - Current Users
  cat("\nAlcohol Use - Women - Current Users:\n")
  counts_w_current <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 1 & current_users], useNA = "ifany")
  perc_w_current <- round(prop.table(counts_w_current) * 100, 1)
  for(i in seq_along(counts_w_current)) {
    cat("  ", names(counts_w_current)[i], ": ", counts_w_current[i], " (", perc_w_current[i], "%)\n", sep = "")
  }
  
  # Women - Past Users
  cat("\nAlcohol Use - Women - Past Users:\n")
  counts_w_past <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 1 & past_users], useNA = "ifany")
  perc_w_past <- round(prop.table(counts_w_past) * 100, 1)
  for(i in seq_along(counts_w_past)) {
    cat("  ", names(counts_w_past)[i], ": ", counts_w_past[i], " (", perc_w_past[i], "%)\n", sep = "")
  }
  
  # Men - Current Users
  cat("\nAlcohol Use - Men - Current Users:\n")
  counts_m_current <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 2 & current_users], useNA = "ifany")
  perc_m_current <- round(prop.table(counts_m_current) * 100, 1)
  for(i in seq_along(counts_m_current)) {
    cat("  ", names(counts_m_current)[i], ": ", counts_m_current[i], " (", perc_m_current[i], "%)\n", sep = "")
  }
  
  # Men - Past Users
  cat("\nAlcohol Use - Men - Past Users:\n")
  counts_m_past <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 2 & past_users], useNA = "ifany")
  perc_m_past <- round(prop.table(counts_m_past) * 100, 1)
  for(i in seq_along(counts_m_past)) {
    cat("  ", names(counts_m_past)[i], ": ", counts_m_past[i], " (", perc_m_past[i], "%)\n", sep = "")}}

# Statistical tests for alcohol use - Current vs Past Users by sex
  # Women: Current vs Past Users
  women_data <- final_dataset_imputed[final_dataset_imputed$sex == 1 & !is.na(final_dataset_imputed$alc_use_combined), ]
  cont_table_women <- table(women_data$alc_use_combined, women_data$scrn_stopped_bzra)
  chi_result_women <- tryCatch(suppressWarnings(chisq.test(cont_table_women)), error = function(e) NULL)
  if(!is.null(chi_result_women) && !is.na(chi_result_women$statistic)) {
    p_val <- if(chi_result_women$p.value < 0.001) "< 0.001" else round(chi_result_women$p.value, 4)
    cramers_v <- sqrt(chi_result_women$statistic / (sum(cont_table_women) * (min(dim(cont_table_women)) - 1)))
    cat("  Women - Current vs Past Users: Cramér's V =", round(cramers_v, 3), ", p-value =", p_val, "\n")}
  
  # Men: Current vs Past Users
  men_data <- final_dataset_imputed[final_dataset_imputed$sex == 2 & !is.na(final_dataset_imputed$alc_use_combined), ]
  cont_table_men <- table(men_data$alc_use_combined, men_data$scrn_stopped_bzra)
  chi_result_men <- tryCatch(suppressWarnings(chisq.test(cont_table_men)), error = function(e) NULL)
  if(!is.null(chi_result_men) && !is.na(chi_result_men$statistic)) {
    p_val <- if(chi_result_men$p.value < 0.001) "< 0.001" else round(chi_result_men$p.value, 4)
    cramers_v <- sqrt(chi_result_men$statistic / (sum(cont_table_men) * (min(dim(cont_table_men)) - 1)))
    cat("  Men - Current vs Past Users: Cramér's V =", round(cramers_v, 3), ", p-value =", p_val, "\n")}

cat("\n=== DESCRIPTIVES BY BZRA STATUS COMPLETE ===\n")
```


## Cluster Analysis For Personality and Demographics

This section will be used for my cluster analysis. I will start by removing the outcome variable and then running a cluster analysis only on the personality/demographic variables to see what emerges from that.

```{r}
#| label: Cluster Analysis
######
# UNSUPERVISED CLUSTER ANALYSIS - OUTCOME-AGNOSTIC APPROACH
# Remove outcome variable to allow natural phenotype discovery
######

# === ENHANCED CLUSTERING WITH COMPLETE DEMOGRAPHIC VARIABLES ===
cat("=== ENHANCED CLUSTERING WITH COMPLETE DEMOGRAPHICS ===\n")
cat("Outcome-agnostic approach with expanded demographic variables\n\n")

# Load required libraries
library(cluster)
library(factoextra)
library(dplyr)
library(tidyr)

# === DEFINE EXPANDED CLUSTERING VARIABLES ===
cat("=== VARIABLE COMPLETENESS CHECK ===\n")

# Core complete variables including expanded demographics
core_clustering_vars <- c(
  # DBAS scales
  "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", "DBAS_Medications",
  # Personality
  "Extraversion", "Agreeableness", "Conscientiousness", "Neuroticism", "Openness",
  # SURPS
  "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", "SURPS_Anxiety_Sensitivity",
  # CISS
  "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
  # Other complete scales
  "osss_3_score", "phq2_score",
  # Demographics - expanded
  "age", "sex", "gender", "prov_terr_region", "education_level", 
  "employment_status", "driving_freq", "income"
)

# Check which variables actually exist in the dataset
available_vars <- core_clustering_vars[core_clustering_vars %in% names(final_dataset_imputed)]
missing_vars <- core_clustering_vars[!core_clustering_vars %in% names(final_dataset_imputed)]

if(length(missing_vars) > 0) {
  cat("Variables not found in dataset:", paste(missing_vars, collapse = ", "), "\n")
}
cat("Available variables:", length(available_vars), "out of", length(core_clustering_vars), "\n")

# Handle prov_terr_region missing data (if it exists)
if("prov_terr_region" %in% available_vars) {
  missing_prov_count <- sum(is.na(final_dataset_imputed$prov_terr_region))
  if(missing_prov_count > 0) {
    cat("Found", missing_prov_count, "missing prov_terr_region values\n")
    
    # Impute with mode (most common province/territory)
    mode_prov <- names(sort(table(final_dataset_imputed$prov_terr_region, useNA = "no"), 
                           decreasing = TRUE))[1]
    final_dataset_imputed$prov_terr_region[is.na(final_dataset_imputed$prov_terr_region)] <- mode_prov
    
    cat("✓ Imputed missing prov_terr_region with mode:", mode_prov, "\n")
  }
}
cat("\n")

# Check completeness of available variables
completeness_check <- final_dataset_imputed %>%
  select(all_of(available_vars)) %>%
  summarise_all(~sum(is.na(.))) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "missing_count") %>%
  mutate(
    total_n = nrow(final_dataset_imputed),
    percent_missing = round(missing_count / total_n * 100, 1),
    complete = missing_count == 0
  ) %>%
  arrange(percent_missing)

cat("Variable completeness summary:\n")
print(completeness_check)

# Filter to only truly complete variables
truly_complete_vars <- completeness_check %>%
  filter(complete == TRUE) %>%
  pull(variable)

cat("\n✓ Truly complete variables:", length(truly_complete_vars), "\n")
cat("Complete variables:", paste(truly_complete_vars, collapse = ", "), "\n\n")

# === CREATE CLUSTERING DATASET ===
cat("=== CREATING CLUSTERING DATASET ===\n")

# Create clustering dataset with proper handling of categorical variables
# Identify which categorical variables are actually present
potential_cat_vars <- c("sex", "gender", "prov_terr_region", "education_level", 
                       "employment_status", "driving_freq", "income")
actual_cat_vars <- intersect(potential_cat_vars, truly_complete_vars)

cat("Categorical variables found:", paste(actual_cat_vars, collapse = ", "), "\n")

core_cluster_data <- final_dataset_imputed %>%
  select(all_of(truly_complete_vars)) %>%
  # Convert categorical variables to factors if they exist
  {if(length(actual_cat_vars) > 0) 
    mutate(., across(all_of(actual_cat_vars), as.factor)) 
   else .} %>%
  filter(complete.cases(.))

cat("✓ Clustering dataset:", nrow(core_cluster_data), "participants x", ncol(core_cluster_data), "variables\n")

# Check data types
cat("\nData types:\n")
sapply(core_cluster_data, class) %>% print()

# === MIXED-DATA CLUSTERING WITH GOWER DISTANCE ===
cat("\n=== MIXED-DATA CLUSTERING (GOWER DISTANCE + PAM) ===\n")

# Calculate Gower distance (handles mixed data types)
cat("Calculating Gower distance matrix...\n")
gower_dist <- daisy(core_cluster_data, metric = "gower")
cat("✓ Distance matrix computed\n")

# === DETERMINE OPTIMAL NUMBER OF CLUSTERS ===
cat("\n=== OPTIMAL NUMBER OF CLUSTERS (PAM + SILHOUETTE) ===\n")

max_k <- min(10, floor(sqrt(nrow(core_cluster_data)/2)))
cat("Testing k from 2 to", max_k, "\n")

# Silhouette method for PAM
silhouette_scores_pam <- numeric(max_k-1)
cat("Silhouette scores:\n")
for(k in 2:max_k) {
  pam_result <- pam(gower_dist, k = k)
  sil_score <- pam_result$silinfo$avg.width
  silhouette_scores_pam[k-1] <- sil_score
  cat(sprintf("  k=%d: Avg Silhouette=%.3f\n", k, sil_score))
}

# Find optimal k
optimal_k_pam <- which.max(silhouette_scores_pam) + 1
cat(sprintf("\n✓ Optimal k by Silhouette: %d (score=%.3f)\n", optimal_k_pam, max(silhouette_scores_pam)))

# === FINAL CLUSTERING ===
cat("\n=== FINAL PAM CLUSTERING ===\n")

final_k <- optimal_k_pam
cat("Using k =", final_k, "clusters\n")

# Perform final clustering
final_pam <- pam(gower_dist, k = final_k)

cat("Clustering results:\n")
cat("  Average Silhouette Width:", round(final_pam$silinfo$avg.width, 3), "\n")

# Cluster sizes
cat("  Cluster sizes:\n")
cluster_sizes <- table(final_pam$clustering)
for(i in 1:final_k) {
  cat(sprintf("    Cluster %d: n=%d (%.1f%%)\n", 
              i, cluster_sizes[i], cluster_sizes[i]/sum(cluster_sizes)*100))
}

# === CLUSTER VALIDATION ===
cat("\n=== CLUSTER VALIDATION ===\n")

avg_sil_width <- final_pam$silinfo$avg.width
cat("Average Silhouette Width:", round(avg_sil_width, 3), "\n")

if(avg_sil_width > 0.5) {
  cat("✓ Good cluster structure\n")
} else if(avg_sil_width > 0.25) {
  cat("⚠️  Moderate cluster structure\n")
} else {
  cat("⚠️  Weak cluster structure\n")
}

# === ALTERNATIVE: K-MEANS WITH DUMMY VARIABLES ===
cat("\n=== ALTERNATIVE: K-MEANS WITH DUMMY VARIABLES ===\n")

# Identify categorical variables
cat_vars <- sapply(core_cluster_data, is.factor)
if(any(cat_vars)) {
  cat("Creating dummy variables for categorical predictors...\n")
  
  # Create dummy variables using base R (no additional package needed)
  # Convert factors to dummy variables manually
  numeric_data <- core_cluster_data %>%
    select_if(is.numeric)
  
  categorical_data <- core_cluster_data %>%
    select_if(is.factor)
  
  # Create dummy variables for each categorical variable
  dummy_list <- list()
  for(var_name in names(categorical_data)) {
    var_levels <- levels(categorical_data[[var_name]])
    # Create dummy variables (excluding first level to avoid multicollinearity)
    for(level in var_levels[-1]) {
      dummy_name <- paste0(var_name, "_", level)
      dummy_list[[dummy_name]] <- as.numeric(categorical_data[[var_name]] == level)
    }
  }
  
  # Combine numeric and dummy variables
  if(length(dummy_list) > 0) {
    dummy_df <- do.call(cbind, dummy_list) %>% as.data.frame()
    core_cluster_data_dummies <- cbind(numeric_data, dummy_df) %>%
      scale()
  } else {
    core_cluster_data_dummies <- numeric_data %>%
      scale()
  }
  
  # K-means clustering
  set.seed(123)
  kmeans_result <- kmeans(core_cluster_data_dummies, centers = final_k, nstart = 50, iter.max = 300)
  
  # Calculate silhouette for k-means
  sil_kmeans <- silhouette(kmeans_result$cluster, dist(core_cluster_data_dummies))
  avg_sil_kmeans <- mean(sil_kmeans[,3])
  
  cat("K-means results:\n")
  cat("  Average Silhouette Width:", round(avg_sil_kmeans, 3), "\n")
  cat("  Total WSS:", round(kmeans_result$tot.withinss, 2), "\n")
  cat("  Between SS / Total SS:", round(kmeans_result$betweenss/kmeans_result$totss * 100, 1), "%\n")
  
  # Cluster sizes
  cat("  Cluster sizes:\n")
  kmeans_sizes <- table(kmeans_result$cluster)
  for(i in 1:final_k) {
    cat(sprintf("    Cluster %d: n=%d (%.1f%%)\n", 
                i, kmeans_sizes[i], kmeans_sizes[i]/sum(kmeans_sizes)*100))
  }
  
  cat("\n=== METHOD COMPARISON ===\n")
  cat("PAM (Gower distance)  - Silhouette:", round(avg_sil_width, 3), "\n")
  cat("K-means (dummy vars)  - Silhouette:", round(avg_sil_kmeans, 3), "\n")
  
  # Choose best method
  if(avg_sil_width >= avg_sil_kmeans) {
    cat("✓ Using PAM clustering (better silhouette)\n")
    final_cluster_method <- "PAM"
    final_clusters <- final_pam$clustering
  } else {
    cat("✓ Using K-means clustering (better silhouette)\n")
    final_cluster_method <- "K-means"
    final_clusters <- kmeans_result$cluster
  }
} else {
  cat("No categorical variables found, using PAM results\n")
  final_cluster_method <- "PAM"
  final_clusters <- final_pam$clustering
}

# === SAVE RESULTS ===
cat("\n=== SAVING RESULTS ===\n")

# Add cluster assignments to main dataset
final_dataset_imputed$cluster_assignment_enhanced <- NA
complete_rows <- complete.cases(final_dataset_imputed[, truly_complete_vars])
final_dataset_imputed$cluster_assignment_enhanced[complete_rows] <- final_clusters

# Save to global environment
assign("core_cluster_data", core_cluster_data, envir = .GlobalEnv)
assign("final_pam", final_pam, envir = .GlobalEnv)
assign("truly_complete_vars", truly_complete_vars, envir = .GlobalEnv)
assign("gower_dist", gower_dist, envir = .GlobalEnv)

if(exists("kmeans_result")) {
  assign("kmeans_result_enhanced", kmeans_result, envir = .GlobalEnv)
}

# Final summary
assignment_summary <- final_dataset_imputed %>%
  count(cluster_assignment_enhanced, name = "n") %>%
  mutate(percent = round(n/sum(n)*100, 1)) %>%
  arrange(cluster_assignment_enhanced)

cat("Final cluster assignment summary:\n")
print(assignment_summary)

cat("\n✓ Enhanced clustering analysis complete\n")
cat("✓ Method used:", final_cluster_method, "\n")
cat("✓ Variables used:", length(truly_complete_vars), "\n")
cat("✓ Cluster assignments saved to final_dataset_imputed$cluster_assignment_enhanced\n")
cat("✓ Ready for cluster characterization and outcome validation\n")
```




