---
title: "Testing"
author: "POC"
format: html
editor: visual
---

## Testing

I will use this document to work on my SIMOA code since I am having trouble with it currently in the existing format. In this way I can mess around with this code and not be worried about it impacting my original data and now that I know what I want to do for my clusters it is easier for me to manipulate the variables in a manner that will set me up for success later.

## Loading the Data

The section I will use to lead the dataset that I will use for the analysis.

```{r}
#| label: Loading the Data and Libraries
######
# Loading required libraries and data
# In this section I will load all necessary packages and the dataset I want to use and name it "SIMOA" 
# so it is easier to call back on later and i know that this is my original dataset.
######

# Load all required libraries
library(readr)        # For reading CSV files
library(tidyverse)    # For data manipulation (dplyr, ggplot2, etc.)
library(mice)         # For multiple imputation
library(VIM)          # For visualizing missing data
library(naniar)       # For missing data exploration
library(effsize)      # For effect size calculations
library(ggplot2)      # For plotting (part of tidyverse but explicit)

# Load the dataset
SIMOA <- read_csv("SIMOA Report.csv")
#View(SIMOA)
```

## Eligible Participants

The section where I have set out the inclusion criteria to remove people from the dataset that do not meet our criteria.

```{r}
#| label: Eligible Participants
######
# In this section I will filter out those who have indicated they are <65 or that have not answered   
# yes to the question about age category or not answered either question. I will also filter out those 
# who did not select one of the 14 BZRAs listed because we do not want the results to be affected by 
# other sedating medications such as antihistamines or SSRI's.
######

# Original count
n_original <- nrow(SIMOA)

# After age filtering
SIMOA_age_filtered <- SIMOA %>%
  filter(age_cat == 1 | (age_cat == 0 & age >= 65))
n_after_age <- nrow(SIMOA_age_filtered)

# After both filters
SIMOA <- SIMOA_age_filtered %>%
  filter(rowSums(select(., starts_with("c_sp___"))[, 1:14] == 1, na.rm = TRUE) > 0)
n_final <- nrow(SIMOA)

# Report results
cat("Original sample:", n_original, "\n")
cat("After age filtering:", n_after_age, "(removed:", n_original - n_after_age, ")\n")
cat("After c_sp filtering:", n_final, "(removed:", n_after_age - n_final, ")\n")
cat("Total removed:", n_original - n_final, "\n")
```


## Calculating Subscale Scores

The section where I go about calculating the subscale scores for all the measures and ensure that this is properly done and that way I can compare the groups in subscales rather than the full measure and it makes it easier to report.

```{r}
#| label: Subscale Scores
######
# In this section I will get the subscale scores for all the measures I have used. I will also ensure
# that items are appropriately reverse-coded.
# All subscale score coding will be found in this chunk but I have divided them to make them easy to 
# find. I would rather have 1 chunk that way it cuts down on the amount of space being taken up for this step.
######

# First, let's create a working copy
data_personality <- SIMOA

######
# BFI-10 SUBSCALE SCORES
######

# Items to reverse: reserved, find_fault, lazy, relaxed, few_interests
# Formula: reversed_score = 6 - original_score
data_personality <- data_personality %>%
  mutate(
    reserved_rev = 6 - reserved,
    find_fault_rev = 6 - find_fault,
    lazy_rev = 6 - lazy,
    relaxed_rev = 6 - relaxed,
    few_interests_rev = 6 - few_interests
  )

# Verifying Reverse-Coding
data_personality %>%
  select(reserved, reserved_rev, find_fault, find_fault_rev, lazy, lazy_rev, 
         relaxed, relaxed_rev, few_interests, few_interests_rev) %>%
  head(10)

# Verify the math: original + reversed should equal 6
verification_check <- data_personality %>%
  mutate(
    reserved_sum = reserved + reserved_rev,
    find_fault_sum = find_fault + find_fault_rev,
    lazy_sum = lazy + lazy_rev,
    relaxed_sum = relaxed + relaxed_rev,
    few_interests_sum = few_interests + few_interests_rev
  ) %>%
  select(ends_with("_sum"))

cat("BFI-10 Reverse coding verification (all should equal 6):\n")
summary(verification_check)

# Creating personality total scores
data_personality <- data_personality %>%
  mutate(
    # Extraversion: reserved (reversed) + outgoing
    Extraversion = reserved_rev + outgoing,
    
    # Agreeableness: trusting + find_fault (reversed)
    Agreeableness = trusting + find_fault_rev,
    
    # Conscientiousness: lazy (reversed) + thorough
    Conscientiousness = lazy_rev + thorough,
    
    # Neuroticism: relaxed (reversed) + nervous
    Neuroticism = relaxed_rev + nervous,
    
    # Openness: few_interests (reversed) + imagination
    Openness = few_interests_rev + imagination
  )

######
# SURPS SUBSCALE SCORES
######

# First, reverse code SURPS Hopelessness items (all except surps17)
# Formula for 1-4 scale: reversed_score = 5 - original_score
data_personality <- data_personality %>%
  mutate(
    surps1_rev = 5 - surps1,
    surps4_rev = 5 - surps4,
    surps7_rev = 5 - surps7,
    surps13_rev = 5 - surps13,
    surps20_rev = 5 - surps20,
    surps23_rev = 5 - surps23
    # Note: surps17 is NOT reversed
  )

# Quick verification - all sums should equal 5
cat("SURPS reverse coding verification (all should equal 5):\n")
print(unique(data_personality$surps1 + data_personality$surps1_rev))
print(unique(data_personality$surps4 + data_personality$surps4_rev))
print(unique(data_personality$surps7 + data_personality$surps7_rev))

# Create SURPS total scores
data_personality <- data_personality %>%
  mutate(
    # Impulsivity: surps2, surps5, surps11, surps15, surps22
    SURPS_Impulsivity = surps2 + surps5 + surps11 + surps15 + surps22,
    
    # Sensation Seeking: surps3, surps6, surps9, surps12, surps16, surps19
    SURPS_Sensation_Seeking = surps3 + surps6 + surps9 + surps12 + surps16 + surps19,
    
    # Hopelessness: surps1(rev), surps4(rev), surps7(rev), surps13(rev), surps17, surps20(rev), surps23(rev)
    SURPS_Hopelessness = surps1_rev + surps4_rev + surps7_rev + surps13_rev + surps17 + surps20_rev + surps23_rev,
    
    # Anxiety Sensitivity: surps8, surps10, surps14, surps18, surps21
    SURPS_Anxiety_Sensitivity = surps8 + surps10 + surps14 + surps18 + surps21
  )

######
# DBAS SUBSCALE SCORES
######

# Response scale: 0-10 (0 = Strongly Disagree, 10 = Strongly Agree)
# No reverse coding needed for DBAS-16
data_personality <- data_personality %>%
  mutate(
    # Expectations subscale (2 items)
    DBAS_Expectations = rowMeans(select(., dbas1, dbas_2), na.rm = TRUE),
    
    # Medications subscale (3 items) 
    DBAS_Medications = rowMeans(select(., dbas_6, dbas_13, dbas_15), na.rm = TRUE),
    
    # Worry/Helplessness subscale (6 items)
    DBAS_Worry_Helplessness = rowMeans(select(., dbas_3, dbas_4, dbas_8, dbas_10, dbas_11, dbas_14), na.rm = TRUE),
    
    # Consequences subscale (5 items)
    DBAS_Consequences = rowMeans(select(., dbas_5, dbas_7, dbas_9, dbas_12, dbas_16), na.rm = TRUE)
  )

# DBAS verification
cat("DBAS-16 Subscale Summary:\n")
data_personality %>%
  select(DBAS_Expectations, DBAS_Medications, DBAS_Worry_Helplessness, DBAS_Consequences) %>%
  summary()

######
# CISS SUBSCALE SCORES
######

data_personality <- data_personality %>%
  mutate(
    # Avoidance Style: ciss1, ciss4, ciss7, ciss9, ciss15, ciss18, ciss21
    CISS_Avoidance_Style = ciss1 + ciss4 + ciss7 + ciss9 + ciss15 + ciss18 + ciss21,
    
    # Task Style: ciss2, ciss6, ciss8, ciss11, ciss13, ciss16, ciss19
    CISS_Task_Style = ciss2 + ciss6 + ciss8 + ciss11 + ciss13 + ciss16 + ciss19,
    
    # Emotional Style: ciss3, ciss5, ciss10, ciss12, ciss14, ciss17, ciss20
    CISS_Emotional_Style = ciss3 + ciss5 + ciss10 + ciss12 + ciss14 + ciss17 + ciss20
  )

# Calculate DBAS total score (sum of all subscales)
data_personality <- data_personality %>%
  mutate(
    # Total DBAS score (sum of all 4 subscales)
    dbas_score = DBAS_Expectations + DBAS_Medications + DBAS_Worry_Helplessness + DBAS_Consequences
  )

# Verification for DBAS total score
cat("DBAS Total Score Summary:\n")
summary(data_personality$dbas_score)
cat("Expected range: 0-10 (average of subscales) or sum of raw items\n\n")
```


## Data Preperation

This section prepare the data for MI and only include those with a complete scrn_stopped_bzra

```{r}
#| label: Data Preparation for Multiple Imputation
######
# Prepare data_personality dataset for multiple imputation
# Include specific variables and create combined adverse effects variables
######

library(dplyr)
library(mice)

cat("=== DATA PREPARATION FOR MULTIPLE IMPUTATION ===\n")

# Start with data_personality dataset
cat("Original data_personality size:", nrow(data_personality), "\n")
cat("Cases with missing scrn_stopped_bzra:", sum(is.na(data_personality$scrn_stopped_bzra)), "\n")

# Filter to only include cases where scrn_stopped_bzra is not NA
data_personality <- data_personality[!is.na(data_personality$scrn_stopped_bzra), ]
cat("Valid outcome cases included:", nrow(data_personality), "\n")

# Verify outcome variable distribution
cat("scrn_stopped_bzra distribution:\n")
print(table(data_personality$scrn_stopped_bzra, useNA = "ifany"))

######
# CREATE COMBINED ADVERSE EFFECTS VARIABLES
######

cat("\n=== CREATING COMBINED ADVERSE EFFECTS VARIABLES ===\n")

# Define adverse effects variable pairs for combination
adverse_var_pairs <- list(
  side_effects_1_combined = c("side_effects_1", "side_effects_1_v2"),
  side_effects_2_combined = c("side_effects_2", "side_effects_2_v2"),
  side_effects_3_combined = c("side_effects_3", "side_effects_3_v2"),
  side_effects_4_combined = c("side_effects_4", "side_effects_4_v2"),
  safety_1_combined = c("safety_1", "safety_1_v2"),
  safety_2_combined = c("safety_2", "safety_2_v2"),
  safety_3_combined = c("safety_3", "safety_3_v2"),
  safety_4_combined = c("safety_4", "safety_4_v2"),
  adls_1_combined = c("adls_1", "adls_1_v2"),
  adls_2_combined = c("adls_2", "adls_2_v2"),
  dependence_1_combined = c("dependence_1", "dependence_1_v2"),
  dependence_2_combined = c("dependence_2", "dependence_2_v2"),
  dependence_3_combined = c("dependence_3", "dependence_3_v2")
)

# Create combined variables by taking the first non-missing value
for(combined_var in names(adverse_var_pairs)) {
  var1 <- adverse_var_pairs[[combined_var]][1]
  var2 <- adverse_var_pairs[[combined_var]][2]
  
  if(var1 %in% names(data_personality) && var2 %in% names(data_personality)) {
    # Create combined variable: use var1 if not missing, otherwise use var2
    data_personality[[combined_var]] <- ifelse(
      !is.na(data_personality[[var1]]), 
      data_personality[[var1]], 
      data_personality[[var2]]
    )
    cat("Created:", combined_var, "from", var1, "and", var2, "\n")
  } else if(var1 %in% names(data_personality)) {
    # Only var1 exists
    data_personality[[combined_var]] <- data_personality[[var1]]
    cat("Created:", combined_var, "from", var1, "only\n")
  } else if(var2 %in% names(data_personality)) {
    # Only var2 exists
    data_personality[[combined_var]] <- data_personality[[var2]]
    cat("Created:", combined_var, "from", var2, "only\n")
  } else {
    cat("Warning: Neither", var1, "nor", var2, "found in dataset\n")
  }
}

######
# DEFINE VARIABLES FOR ANALYSIS
######

cat("\n=== SELECTING VARIABLES FOR ANALYSIS ===\n")

# Core variables requested
core_vars <- c(
  "age", "sex", "gender",
  "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", "DBAS_Medications", "dbas_score",
  "Openness", "Conscientiousness", "Extraversion", "Agreeableness", "Neuroticism",
  "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", "SURPS_Anxiety_Sensitivity",
  "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
  "osss_3_score", "phq2_score",
  "prov_terr", "education", "employment", "driving_freq", "income",
  "med_quant", "op_use", "can_use", "alc_sleep", "can_sleep", "melatonin_use", "op_sleep", "quet_use", "traz_use", "otc_use",
  "alc_use_wmn", "alc_use_men"
)

# Combined adverse effects variables
combined_vars <- names(adverse_var_pairs)

# All variables for analysis
all_analysis_vars <- c(core_vars, combined_vars)

cat("Total variables requested:", length(all_analysis_vars), "\n")

######
# CHECK VARIABLE AVAILABILITY AND CREATE SUBSET
######

# Check which variables are available
available_vars <- all_analysis_vars[all_analysis_vars %in% names(data_personality)]
missing_vars <- all_analysis_vars[!all_analysis_vars %in% names(data_personality)]

cat("Variables available:", length(available_vars), "\n")
cat("Variables not found:", length(missing_vars), "\n")

if(length(missing_vars) > 0) {
  cat("\nMissing variables:\n")
  for(var in missing_vars) {
    cat("  -", var, "\n")
  }
}

# Create analysis dataset with available variables
final_dataset_imputed <- data_personality[, available_vars, drop = FALSE]

######
# HANDLE CONDITIONAL SUBSTANCE USE VARIABLES
######

cat("\n=== HANDLING CONDITIONAL SUBSTANCE USE VARIABLES ===\n")

# These variables were only shown to participants who selected them in previous questions
# NA means they never use these substances, so recode NA to 0 ("Never")
conditional_vars <- c("op_use", "can_use", "alc_sleep", "can_sleep", "melatonin_use", "op_sleep", "quet_use", "traz_use", "otc_use")

for(var in conditional_vars) {
  if(var %in% names(final_dataset_imputed)) {
    original_na_count <- sum(is.na(final_dataset_imputed[[var]]))
    
    # Recode NA to 0 (Never used)
    final_dataset_imputed[[var]][is.na(final_dataset_imputed[[var]])] <- 0
    
    cat("Recoded", original_na_count, "NA values to 0 ('Never') for", var, "\n")
  }
}

# Handle sex-specific alcohol use variables
cat("\n=== HANDLING SEX-SPECIFIC ALCOHOL USE VARIABLES ===\n")

# alc_use_wmn: Only shown if sex = 1 (women)
if("alc_use_wmn" %in% names(final_dataset_imputed) && "sex" %in% names(final_dataset_imputed)) {
  # For men (sex = 2), recode NA to appropriate "Never" value (0)
  # For women (sex = 1), keep NA as true missing data for imputation
  men_na_count <- sum(is.na(final_dataset_imputed$alc_use_wmn) & final_dataset_imputed$sex == 2, na.rm = TRUE)
  final_dataset_imputed$alc_use_wmn[final_dataset_imputed$sex == 2 & is.na(final_dataset_imputed$alc_use_wmn)] <- 0
  cat("Recoded", men_na_count, "NA values to 0 ('Never') for alc_use_wmn in men (sex=2)\n")
  
  # Report remaining missing data in women
  women_na_count <- sum(is.na(final_dataset_imputed$alc_use_wmn) & final_dataset_imputed$sex == 1, na.rm = TRUE)
  cat("Remaining missing data for alc_use_wmn in women (sex=1):", women_na_count, "\n")
}

# alc_use_men: Only shown if sex = 2 (men)  
if("alc_use_men" %in% names(final_dataset_imputed) && "sex" %in% names(final_dataset_imputed)) {
  # For women (sex = 1), recode NA to appropriate "Never" value (1, based on the scale)
  # For men (sex = 2), keep NA as true missing data for imputation
  women_na_count <- sum(is.na(final_dataset_imputed$alc_use_men) & final_dataset_imputed$sex == 1, na.rm = TRUE)
  final_dataset_imputed$alc_use_men[final_dataset_imputed$sex == 1 & is.na(final_dataset_imputed$alc_use_men)] <- 1
  cat("Recoded", women_na_count, "NA values to 1 ('Never') for alc_use_men in women (sex=1)\n")
  
  # Report remaining missing data in men
  men_na_count <- sum(is.na(final_dataset_imputed$alc_use_men) & final_dataset_imputed$sex == 2, na.rm = TRUE)
  cat("Remaining missing data for alc_use_men in men (sex=2):", men_na_count, "\n")
}

# Create a combined alcohol use variable
if("alc_use_wmn" %in% names(final_dataset_imputed) && "alc_use_men" %in% names(final_dataset_imputed) && "sex" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$alc_use_combined <- case_when(
    final_dataset_imputed$sex == 1 ~ final_dataset_imputed$alc_use_wmn,  # Use women's scale for women
    final_dataset_imputed$sex == 2 ~ final_dataset_imputed$alc_use_men,  # Use men's scale for men
    TRUE ~ NA_real_
  )
  cat("Created combined alcohol use variable (alc_use_combined)\n")
}

######
# CREATE REGIONAL, EDUCATION, AND EMPLOYMENT GROUPINGS
######

cat("\n=== CREATING DEMOGRAPHIC GROUPINGS ===\n")

# Regional groupings
if("prov_terr" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$prov_terr_region <- case_when(
    final_dataset_imputed$prov_terr %in% c(1, 2, 3, 12) ~ "Prairies",
    final_dataset_imputed$prov_terr %in% c(9, 11) ~ "Central Canada", 
    final_dataset_imputed$prov_terr %in% c(4, 5, 7, 10) ~ "Atlantic Canada",
    final_dataset_imputed$prov_terr %in% c(6, 8, 13) ~ "Territories",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$prov_terr_region <- factor(final_dataset_imputed$prov_terr_region,
                                                   levels = c("Prairies", "Central Canada", 
                                                              "Atlantic Canada", "Territories"))
  cat("Created regional groupings from prov_terr\n")
}

# Education groupings
if("education" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$education_level <- case_when(
    final_dataset_imputed$education %in% c(1, 2, 3) ~ "High School or Less",
    final_dataset_imputed$education %in% c(4, 5) ~ "Trade School/University",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$education_level <- factor(final_dataset_imputed$education_level,
                                                  levels = c("High School or Less", "Trade School/University"))
  cat("Created education level groupings from education\n")
}

# Employment groupings
if("employment" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$employment_status <- case_when(
    final_dataset_imputed$employment %in% c(0, 3, 4) ~ "Retired/Not in Workforce",
    final_dataset_imputed$employment %in% c(1, 2) ~ "Full- or Part-Time",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$employment_status <- factor(final_dataset_imputed$employment_status,
                                                    levels = c("Full- or Part-Time", "Retired/Not in Workforce"))
  cat("Created employment status groupings from employment\n")
}

######
# FINAL DATASET SUMMARY
######

cat("\n=== FINAL DATASET SUMMARY ===\n")
cat("Final dataset dimensions:", dim(final_dataset_imputed), "\n")
cat("Number of participants:", nrow(final_dataset_imputed), "\n")
cat("Number of variables:", ncol(final_dataset_imputed), "\n")

# Missing data summary
cat("\n=== MISSING DATA SUMMARY ===\n")
missing_summary <- sapply(final_dataset_imputed, function(x) sum(is.na(x)))
variables_with_missing <- missing_summary[missing_summary > 0]

if(length(variables_with_missing) > 0) {
  cat("Variables with missing data:\n")
  for(i in 1:length(variables_with_missing)) {
    var_name <- names(variables_with_missing)[i]
    missing_count <- variables_with_missing[i]
    missing_pct <- round((missing_count / nrow(final_dataset_imputed)) * 100, 1)
    cat(paste("  ", var_name, ":", missing_count, "(", missing_pct, "%)\n"))
  }
  
  # Overall completeness
  complete_cases <- sum(complete.cases(final_dataset_imputed))
  complete_pct <- round((complete_cases / nrow(final_dataset_imputed)) * 100, 1)
  cat("\nComplete cases:", complete_cases, "out of", nrow(final_dataset_imputed), 
      "(", complete_pct, "%)\n")
} else {
  cat("No missing data found in any variables!\n")
}

cat("\n=== DATA PREPARATION COMPLETE ===\n")
cat("Dataset 'final_dataset_imputed' is ready for multiple imputation analysis\n")
```


## Mice Optimization 

```{r}
#| label: MI Optimization
######
# Systematic optimization for multiple imputation:
# - Determine number of imputations from missingness
# - Pilot run to assess number of iterations
# - Ensure factor levels are clean to avoid convergence errors
######

library(mice)
library(dplyr)

cat("\n=== MULTIPLE IMPUTATION OPTIMIZATION ===\n")

# --- Use dataset from preparation step ---
analysis_data <- final_dataset_imputed

# --- Define variable groups ---
binary_vars  <- c("sex")
ordered_vars <- c("education", "income",
                  "side_effects_1_combined", "side_effects_2_combined",
                  "side_effects_3_combined", "side_effects_4_combined")

# Only keep variables that exist in the dataset
binary_vars  <- intersect(binary_vars,  names(analysis_data))
ordered_vars <- intersect(ordered_vars, names(analysis_data))

# --- Factor conversions ---
if (length(binary_vars) > 0) {
  analysis_data[binary_vars] <- lapply(analysis_data[binary_vars], factor)
}
if (length(ordered_vars) > 0) {
  analysis_data[ordered_vars] <- lapply(analysis_data[ordered_vars], function(x) factor(x, ordered = TRUE))
}

# Unordered categorical (if present)
if ("prov_terr" %in% names(analysis_data)) {
  analysis_data$prov_terr <- factor(analysis_data$prov_terr)
}
if ("prov_terr_region" %in% names(analysis_data)) {
  analysis_data$prov_terr_region <- factor(analysis_data$prov_terr_region)
}
if ("education_level" %in% names(analysis_data)) {
  analysis_data$education_level <- factor(analysis_data$education_level)
}
if ("employment_status" %in% names(analysis_data)) {
  analysis_data$employment_status <- factor(analysis_data$employment_status)
}

# Outcome variable (not imputed)
if ("scrn_stopped_bzra" %in% names(analysis_data)) {
  analysis_data$scrn_stopped_bzra <- factor(analysis_data$scrn_stopped_bzra)
}

# --- Determine number of imputations systematically ---
missing_pct <- mean(is.na(analysis_data)) * 100
m_impute <- ceiling(missing_pct) * 5  # rule of thumb: 5 imputations per % missing
m_impute <- max(20, m_impute)         # enforce a sensible minimum

cat("Estimated missingness:", round(missing_pct, 1), "%\n")
cat("Planned number of imputations:", m_impute, "\n")

# --- Pilot run for iterations ---
cat("\n=== PILOT IMPUTATION RUN (dry-run with small m) ===\n")
init <- mice(analysis_data, maxit = 0, print = FALSE)
meth <- init$method
pred <- init$predictorMatrix

# Ensure problematic variables use PMM
meth[meth %in% c("logreg", "polyreg", "polr")] <- "pmm"

# Pilot run (small m to check stability)
pilot <- tryCatch(
  mice(analysis_data, m = 3, maxit = 5, method = meth, predictorMatrix = pred, seed = 123, print = FALSE),
  error = function(e) e
)

if (inherits(pilot, "error")) {
  cat("✗ Pilot run failed:", pilot$message, "\n")
} else {
  cat("✓ Pilot run successful\n")
  print(pilot)
}

# --- Final note for later imputation ---
cat("\n=== NEXT STEP ===\n")
cat("Once optimization looks stable, run full imputation with m =", m_impute, "and tuned maxit\n")
```







## NEW MULTIPLE IMPUTATION

WORKING ON THIS

```{r}
######
# MULTIPLE IMPUTATION WITH FALLBACK STRATEGIES
######

library(mice)
library(dplyr)

cat("\n=== MULTIPLE IMPUTATION ===\n")

# --- Ensure correct data types ---
binary_vars <- c("sex")
analysis_data[binary_vars] <- lapply(analysis_data[binary_vars], factor)

ordered_vars <- c("education", "income", "gen_health",
                  "side_effects_1_combined", "side_effects_2_combined",
                  "side_effects_3_combined", "side_effects_4_combined",
                  "motivation_1_combined", "motivation_2_combined", "motivation_3_combined")
analysis_data[ordered_vars] <- lapply(analysis_data[ordered_vars], function(x) factor(x, ordered = TRUE))

analysis_data$prov_terr <- factor(analysis_data$prov_terr)
analysis_data$scrn_stopped_bzra <- factor(analysis_data$scrn_stopped_bzra)  # outcome (not imputed)

# --- Create method vector ---
meth <- make.method(analysis_data)

meth[c("age", "phq2_score", "n_health_conditions", "med_quant", "osss_3_score")] <- "pmm"
meth["sex"] <- "logreg"
meth["scrn_stopped_bzra"] <- ""   # do not impute outcome
meth[ordered_vars] <- "polr"
meth["prov_terr"] <- "polyreg"

# --- Predictor matrix ---
pred <- make.predictorMatrix(analysis_data)
pred[, "scrn_stopped_bzra"] <- 0   # exclude outcome as predictor
pred["scrn_stopped_bzra", ] <- 0

# --- Suggested imputations from missingness ---
missing_frac <- colMeans(is.na(analysis_data))
max_missing <- max(missing_frac)
m_suggested <- max(20, ceiling(max_missing * 100))
cat("Suggested number of imputations (m):", m_suggested, "\n")

# --- Define base parameters ---
mice_params <- list(
  data = analysis_data,
  m = m_suggested,
  method = meth,
  predictorMatrix = pred,
  maxit = 20,
  seed = 123
)

mice_result <- NULL
imputation_strategy <- NULL
complete_datasets <- NULL

######
# STRATEGY 1: FULL IMPUTATION (original methods)
######
tryCatch({
  start_time <- Sys.time()
  mice_result_full <- mice(
    data = mice_params$data,
    m = mice_params$m,
    method = mice_params$method,
    predictorMatrix = mice_params$predictorMatrix,
    maxit = mice_params$maxit,
    printFlag = TRUE,
    seed = mice_params$seed
  )
  end_time <- Sys.time()
  execution_time <- difftime(end_time, start_time, units = "mins")
  
  cat("\n✓ SUCCESS: Full imputation completed!\n")
  cat("Execution time:", round(execution_time, 2), "minutes\n")
  
  mice_result <- mice_result_full
  imputation_strategy <- "full"
  complete_datasets <- lapply(1:mice_params$m, function(i) complete(mice_result_full, action = i))
  
}, error = function(e) {
  cat("\n⚠️ ERROR in full imputation:", conditionMessage(e), "\n")
})

######
# STRATEGY 2: PMM-only fallback
######
if (is.null(mice_result)) {
  tryCatch({
    start_time <- Sys.time()
    pmm_methods <- rep("pmm", length(mice_params$method))
    names(pmm_methods) <- names(mice_params$method)
    pmm_methods["scrn_stopped_bzra"] <- ""
    
    mice_result_pmm <- mice(
      data = mice_params$data,
      m = mice_params$m,
      method = pmm_methods,
      predictorMatrix = mice_params$predictorMatrix,
      maxit = mice_params$maxit,
      printFlag = TRUE,
      seed = mice_params$seed
    )
    end_time <- Sys.time()
    execution_time <- difftime(end_time, start_time, units = "mins")
    
    cat("\n✓ SUCCESS: PMM-only imputation completed!\n")
    cat("Execution time:", round(execution_time, 2), "minutes\n")
    
    mice_result <- mice_result_pmm
    imputation_strategy <- "pmm_only"
    # ✅ Ensure complete_datasets exists
    complete_datasets <- lapply(1:mice_params$m, function(i) complete(mice_result_pmm, action = i))
    
  }, error = function(e) {
    cat("\n⚠️ ERROR in PMM-only imputation:", conditionMessage(e), "\n")
  })
}

######
# STRATEGY 3: Reduced iterations
######
if (is.null(mice_result)) {
  tryCatch({
    start_time <- Sys.time()
    mice_result_reduced <- mice(
      data = mice_params$data,
      m = mice_params$m,
      method = mice_params$method,
      predictorMatrix = mice_params$predictorMatrix,
      maxit = 10,
      printFlag = TRUE,
      seed = mice_params$seed
    )
    end_time <- Sys.time()
    execution_time <- difftime(end_time, start_time, units = "mins")
    
    cat("\n✓ SUCCESS: Reduced iterations (10) imputation completed!\n")
    cat("Execution time:", round(execution_time, 2), "minutes\n")
    
    mice_result <- mice_result_reduced
    imputation_strategy <- "reduced_iterations"
    complete_datasets <- lapply(1:mice_params$m, function(i) complete(mice_result_reduced, action = i))
    
  }, error = function(e) {
    cat("\n⚠️ ERROR in reduced iteration imputation:", conditionMessage(e), "\n")
  })
}

######
# STRATEGY 4: 10 imputations
######
if (is.null(mice_result)) {
  tryCatch({
    start_time <- Sys.time()
    mice_result_few <- mice(
      data = mice_params$data,
      m = 10,
      method = mice_params$method,
      predictorMatrix = mice_params$predictorMatrix,
      maxit = mice_params$maxit,
      printFlag = TRUE,
      seed = mice_params$seed
    )
    end_time <- Sys.time()
    execution_time <- difftime(end_time, start_time, units = "mins")
    
    cat("\n✓ SUCCESS: Reduced m (10) imputation completed!\n")
    cat("Execution time:", round(execution_time, 2), "minutes\n")
    
    mice_result <- mice_result_few
    imputation_strategy <- "reduced_m"
    complete_datasets <- lapply(1:10, function(i) complete(mice_result_few, action = i))
    
  }, error = function(e) {
    cat("\n⚠️ ERROR in reduced m imputation:", conditionMessage(e), "\n")
  })
}

######
# STRATEGY 5: Last-resort single imputation
######
if (is.null(mice_result)) {
  tryCatch({
    start_time <- Sys.time()
    mice_result_single <- mice(
      data = mice_params$data,
      m = 1,
      method = mice_params$method,
      predictorMatrix = mice_params$predictorMatrix,
      maxit = 5,
      printFlag = TRUE,
      seed = mice_params$seed
    )
    end_time <- Sys.time()
    execution_time <- difftime(end_time, start_time, units = "mins")
    
    cat("\n✓ SUCCESS: Last-resort single imputation completed!\n")
    cat("Execution time:", round(execution_time, 2), "minutes\n")
    
    mice_result <- mice_result_single
    imputation_strategy <- "single"
    complete_datasets <- list(complete(mice_result_single, action = 1))
    
  }, error = function(e) {
    cat("\n❌ All imputation strategies failed. Error:", conditionMessage(e), "\n")
  })
}

######
# POST-IMPUTATION PROCESSING
######
cat("\n=== POST-IMPUTATION PROCESSING ===\n")

# Add outcome variable back
if (exists("outcome_variable") && !is.null(outcome_variable)) {
  for (i in seq_along(complete_datasets)) {
    complete_datasets[[i]]$scrn_stopped_bzra <- outcome_variable
  }
  cat("Outcome variable restored to all datasets\n")
}

# Create primary dataset
final_imputed_dataset <- complete_datasets[[1]]

cat("Primary imputed dataset ready (strategy:", imputation_strategy, ")\n")
```



```{r}
#| label: MICE Multiple Imputation Execution
######
# Execute MICE imputation and validation
# Requires: mice_parameters object from previous chunk
######

library(mice)
library(VIM)
library(ggplot2)
library(dplyr)

cat("=== RUNNING MICE MULTIPLE IMPUTATION ===\n")

######
# STEP 1: CHECK PREREQUISITES
######

cat("\n=== STEP 1: CHECKING PREREQUISITES ===\n")

# Check if MICE parameters are available
if(!exists("mice_parameters")) {
  stop("ERROR: mice_parameters not found. Please run the MICE setup chunk first.")
} 

if(is.null(mice_parameters)) {
  cat("No MICE imputation needed - all missing data was handled logically\n")
  cat("Final dataset available as 'final_dataset_processed'\n")
  
  # Add outcome variable back to processed dataset
  if(exists("outcome_variable") && !is.null(outcome_variable)) {
    final_dataset_complete <- final_dataset_processed
    final_dataset_complete$scrn_stopped_bzra <- outcome_variable
    cat("Outcome variable added back to complete dataset\n")
    cat("Complete dataset dimensions:", dim(final_dataset_complete), "\n")
    
    # Store globally
    final_dataset_complete <<- final_dataset_complete
  }
  
} else {
  
  cat("MICE parameters loaded successfully\n")
  cat("Dataset dimensions:", dim(mice_parameters$data), "\n")
  cat("Variables to impute:", length(mice_parameters$method[mice_parameters$method != ""]), "\n")
  cat("Number of imputations:", mice_parameters$m, "\n")
  cat("Maximum iterations:", mice_parameters$maxit, "\n")
  
  ######
  # STEP 2: RUN MICE IMPUTATION
  ######
  
  cat("\n=== STEP 2: EXECUTING MICE IMPUTATION ===\n")
  cat("Starting imputation process...\n")
  cat("This may take several minutes depending on dataset size and complexity\n\n")
  
  # Record start time
  start_time <- Sys.time()
  
  # Run MICE imputation
  tryCatch({
    mice_result <- do.call(mice, mice_parameters)
    
    # Record completion time
    end_time <- Sys.time()
    execution_time <- difftime(end_time, start_time, units = "mins")
    
    cat("\n=== MICE IMPUTATION COMPLETED SUCCESSFULLY ===\n")
    cat("Execution time:", round(execution_time, 2), "minutes\n")
    cat("Imputations completed:", mice_result$m, "\n")
    cat("Iterations completed:", mice_result$iteration, "\n")
    
    # Store result globally
    mice_result <<- mice_result
    
  }, error = function(e) {
    cat("\nERROR: MICE imputation failed\n")
    cat("Error message:", e$message, "\n")
    
    # Try to provide helpful debugging information
    cat("\nDebugging information:\n")
    cat("- Check for factor level mismatches\n")
    cat("- Verify all categorical variables have valid levels\n")
    cat("- Consider reducing number of variables or using PMM for problematic variables\n")
    
    stop("MICE imputation failed. See error message above.")
  })
  
  ######
  # STEP 3: CONVERGENCE DIAGNOSTICS
  ######
  
  cat("\n=== STEP 3: CONVERGENCE DIAGNOSTICS ===\n")
  
  # Check convergence for key variables (up to 6 variables)
  vars_to_check <- names(mice_result$method)[mice_result$method != ""][1:min(6, length(names(mice_result$method)[mice_result$method != ""]))]
  
  cat("Checking convergence for variables:", paste(vars_to_check, collapse = ", "), "\n")
  
  tryCatch({
    # Create convergence plots
    conv_plot <- plot(mice_result, vars_to_check)
    print(conv_plot)
    cat("Convergence plots generated successfully\n")
    
    # Check for convergence issues
    conv_issues <- c()
    for(var in vars_to_check) {
      if(var %in% names(mice_result$chainMean)) {
        chain_means <- mice_result$chainMean[[var]]
        if(!is.null(chain_means) && nrow(chain_means) > 1) {
          # Check if chains have converged (simple check)
          final_values <- chain_means[nrow(chain_means), ]
          if(length(final_values) > 1) {
            cv <- sd(final_values) / mean(final_values)
            if(cv > 0.1) {  # Coefficient of variation > 10%
              conv_issues <- c(conv_issues, var)
            }
          }
        }
      }
    }
    
    if(length(conv_issues) > 0) {
      cat("WARNING: Potential convergence issues detected for:", paste(conv_issues, collapse = ", "), "\n")
      cat("Consider increasing 'maxit' parameter or checking variable specifications\n")
    } else {
      cat("Convergence appears satisfactory for checked variables\n")
    }
    
  }, error = function(e) {
    cat("Warning: Could not generate convergence plots:", e$message, "\n")
  })
  
  ######
  # STEP 4: IMPUTATION QUALITY CHECKS
  ######
  
  cat("\n=== STEP 4: IMPUTATION QUALITY ASSESSMENT ===\n")
  
  # Get first complete dataset for comparison
  complete_data_1 <- complete(mice_result, 1)
  
  cat("Quality checks:\n")
  
  # Check 1: Compare distributions of observed vs imputed values
  cat("\n--- Distribution Comparison (Observed vs Imputed) ---\n")
  
  imputed_vars <- names(mice_result$method)[mice_result$method != ""]
  quality_issues <- c()
  
  for(var in imputed_vars[1:min(5, length(imputed_vars))]) {
    tryCatch({
      # Get observed and imputed values
      observed_vals <- mice_result$data[[var]][!is.na(mice_result$data[[var]])]
      imputed_vals <- complete_data_1[[var]][is.na(mice_result$data[[var]])]
      
      if(length(observed_vals) > 0 && length(imputed_vals) > 0) {
        if(is.numeric(observed_vals)) {
          # For continuous variables
          obs_mean <- mean(observed_vals, na.rm = TRUE)
          imp_mean <- mean(imputed_vals, na.rm = TRUE)
          mean_diff <- abs(obs_mean - imp_mean) / obs_mean
          
          cat(sprintf("%s: Observed mean = %.3f, Imputed mean = %.3f (diff: %.1f%%)\n", 
                     var, obs_mean, imp_mean, mean_diff * 100))
          
          if(mean_diff > 0.2) {  # >20% difference
            quality_issues <- c(quality_issues, paste(var, "- large mean difference"))
          }
        } else {
          # For categorical variables
          obs_table <- table(observed_vals)
          imp_table <- table(imputed_vals)
          
          cat(sprintf("%s: Observed levels: %s, Imputed levels: %s\n", 
                     var, 
                     paste(names(obs_table), collapse = ","),
                     paste(names(imp_table), collapse = ",")))
          
          # Check if imputed values include impossible levels
          impossible_levels <- setdiff(names(imp_table), names(obs_table))
          if(length(impossible_levels) > 0) {
            quality_issues <- c(quality_issues, paste(var, "- impossible imputed levels"))
          }
        }
      }
    }, error = function(e) {
      cat(sprintf("%s: Quality check failed - %s\n", var, e$message))
    })
  }
  
  # Check 2: Missing data pattern preservation
  cat("\n--- Missing Data Pattern Check ---\n")
  
  original_missing <- sapply(mice_result$data, function(x) sum(is.na(x)))
  complete_missing <- sapply(complete_data_1, function(x) sum(is.na(x)))
  
  total_original_missing <- sum(original_missing)
  total_remaining_missing <- sum(complete_missing)
  
  cat("Original missing values:", total_original_missing, "\n")
  cat("Remaining missing values after imputation:", total_remaining_missing, "\n")
  cat("Successfully imputed:", total_original_missing - total_remaining_missing, "values\n")
  
  if(total_remaining_missing > 0) {
    vars_still_missing <- names(complete_missing)[complete_missing > 0]
    cat("WARNING: Variables still have missing values:", paste(vars_still_missing, collapse = ", "), "\n")
    quality_issues <- c(quality_issues, "Incomplete imputation")
  }
  
  # Quality summary
  cat("\n--- Quality Assessment Summary ---\n")
  if(length(quality_issues) == 0) {
    cat("✓ All quality checks passed\n")
    cat("✓ Imputation appears successful\n")
  } else {
    cat("⚠ Quality issues detected:\n")
    for(issue in quality_issues) {
      cat("  -", issue, "\n")
    }
    cat("\nConsider reviewing imputation methods or parameters\n")
  }
  
  ######
  # STEP 5: CREATE FINAL DATASETS
  ######
  
  cat("\n=== STEP 5: CREATING FINAL DATASETS ===\n")
  
  # Create pooled dataset (using first imputation as example)
  final_imputed_dataset <- complete(mice_result, 1)
  
  # Add outcome variable back
  if(exists("outcome_variable") && !is.null(outcome_variable)) {
    final_imputed_dataset$scrn_stopped_bzra <- outcome_variable
    cat("Outcome variable 'scrn_stopped_bzra' added back to imputed dataset\n")
  }
  
  # Store all imputed datasets
  all_imputed_datasets <- list()
  for(i in 1:mice_result$m) {
    imputed_data <- complete(mice_result, i)
    if(exists("outcome_variable") && !is.null(outcome_variable)) {
      imputed_data$scrn_stopped_bzra <- outcome_variable
    }
    all_imputed_datasets[[i]] <- imputed_data
  }
  
  cat("Created", length(all_imputed_datasets), "complete imputed datasets\n")
  cat("Final dataset dimensions:", dim(final_imputed_dataset), "\n")
  
  # Store globally
  final_imputed_dataset <<- final_imputed_dataset
  all_imputed_datasets <<- all_imputed_datasets
  
  ######
  # STEP 6: SUMMARY AND NEXT STEPS
  ######
  
  cat("\n=== STEP 6: IMPUTATION SUMMARY ===\n")
  
  cat("MICE IMPUTATION COMPLETED SUCCESSFULLY\n\n")
  
  cat("Objects created:\n")
  cat("- mice_result: Raw MICE output object\n")
  cat("- final_imputed_dataset: First complete dataset (for quick analysis)\n")
  cat("- all_imputed_datasets: List of all", mice_result$m, "imputed datasets\n")
  
  cat("\nImputation details:\n")
  cat("- Number of imputations:", mice_result$m, "\n")
  cat("- Variables imputed:", length(imputed_vars), "\n")
  cat("- Total execution time:", round(execution_time, 2), "minutes\n")
  
  cat("\nNext steps:\n")
  cat("1. For analysis: Use pool() function with fitted models across all imputations\n")
  cat("2. For quick exploration: Use final_imputed_dataset\n")
  cat("3. For complete analysis: Loop through all_imputed_datasets\n")
  
  cat("\nExample usage:\n")
  cat("# Quick analysis (single imputation - less robust):\n")
  cat("model <- glm(scrn_stopped_bzra ~ age + sex, data = final_imputed_dataset, family = binomial)\n\n")
  
  cat("# Proper multiple imputation analysis:\n")
  cat("fits <- with(mice_result, glm(scrn_stopped_bzra ~ age + sex, family = binomial))\n")
  cat("pooled_results <- pool(fits)\n")
  cat("summary(pooled_results)\n")
  
}

cat("\n=== MULTIPLE IMPUTATION PROCESS COMPLETE ===\n")
```


```{r}
```








































## Multiple Imputation

This section applies the findings from the previous 2 chunks to fill in the missing data and then reports the final dataset size.

```{r}
#| label: Multiple Imputation
######
# Apply MICE imputation for missing data
# Only including cases with valid scrn_stopped_bzra responses
######

# Filter to only include cases where scrn_stopped_bzra is not NA
cat("=== FILTERING FOR COMPLETE OUTCOME DATA ===\n")
cat("Original dataset size:", nrow(final_dataset), "\n")
cat("Cases with missing scrn_stopped_bzra:", sum(is.na(data_personality$scrn_stopped_bzra[1:nrow(final_dataset)])), "\n")

# Create indices for cases with valid outcome data
valid_outcome_indices <- which(!is.na(data_personality$scrn_stopped_bzra[1:nrow(final_dataset)]))

# Filter final_dataset to only include cases with valid outcome
final_dataset <- final_dataset[valid_outcome_indices, ]

cat("Filtered dataset size:", nrow(final_dataset), "\n")
cat("Cases removed due to missing outcome:", length(valid_outcome_indices) - nrow(final_dataset) + (nrow(data_personality) - length(valid_outcome_indices)), "\n")

# Set seed for reproducibility
set.seed(123)

# Convert categorical variables to factors
categorical_vars <- c("sex", "gender", "prov_terr", "education", "employment", "driving_freq", "income")
for(var in categorical_vars) {
  if(var %in% names(final_dataset)) {
    if(!is.factor(final_dataset[[var]])) {
      final_dataset[[var]] <- as.factor(final_dataset[[var]])
      cat(paste("Converted", var, "to factor\n"))
    }
  }
}

# Check if we have complete cases for comparison
complete_cases <- sum(complete.cases(final_dataset))
cat("Complete cases before imputation:", complete_cases, "out of", nrow(final_dataset), "\n")

# Apply MICE imputation
cat("\n=== RUNNING MICE IMPUTATION ===\n")
mice_result <- mice(final_dataset, m = 5, method = 'pmm', printFlag = FALSE, seed = 123)

# Get the completed dataset (using the first imputation)
final_dataset_imputed <- complete(mice_result, 1)

# Verify imputation worked
cat("\n=== IMPUTATION VERIFICATION ===\n")
cat("Missing values after MICE:\n")
print(sapply(final_dataset_imputed, function(x) sum(is.na(x))))

cat("\nFinal sample size:", nrow(final_dataset_imputed), "\n")

# Adding the outcome variable back to the imputed dataset for analysis
# Use the valid indices to get the corresponding outcome values
final_dataset_imputed$scrn_stopped_bzra <- data_personality$scrn_stopped_bzra[valid_outcome_indices]

# Verify no missing values in outcome
cat("Missing values in outcome variable:", sum(is.na(final_dataset_imputed$scrn_stopped_bzra)), "\n")
cat("Added outcome variable back to dataset for analysis\n")

# Final verification
cat("\n=== FINAL DATASET SUMMARY ===\n")
cat("Total cases in final imputed dataset:", nrow(final_dataset_imputed), "\n")
cat("Outcome variable distribution:\n")
print(table(final_dataset_imputed$scrn_stopped_bzra, useNA = "ifany"))
```


## Secondary Variables

This section adds variables about adverse effects, dependence, negative daytime experiences, substance use, sleep-related substance use.

These variables could not be imputed because they are not MAR and since they are MNAR multiple imputation is not ideal to analyze the missingness.

```{r}
#| label: Secondary Variable Code
######
# Add adverse effects and substance use variables back to imputed dataset
# These variables are not imputed due to MNAR patterns but kept for secondary analyses
######
cat("=== ADDING SECONDARY VARIABLES FOR CLUSTER ANALYSIS ===\n")

# Define all secondary variables we want to add
secondary_vars_to_add <- c(
  # Adverse effects - current users
  "side_effects_1", "side_effects_2", "side_effects_3", "side_effects_4",
  "safety_1", "safety_2", "safety_3", "safety_4", "adls_1", "adls_2", 
  "dependence_1", "dependence_2", "dependence_3",
  # Adverse effects - past users (v2 versions)
  "side_effects_1_v2", "side_effects_2_v2", "side_effects_3_v2", "side_effects_4_v2",
  "safety_1_v2", "safety_2_v2", "safety_3_v2", "safety_4_v2", "adls_1_v2", "adls_2_v2",
  "dependence_1_v2", "dependence_2_v2", "dependence_3_v2",
  # Substance use variables
  "med_quant", "op_use", "can_use", "alc_use_wmn", "alc_use_men",
  "alc_sleep", "can_sleep", "melatonin_use", "op_sleep", "quet_use", "traz_use", "otc_use"
)

# Check which variables exist in original dataset
existing_secondary_vars <- secondary_vars_to_add[secondary_vars_to_add %in% names(data_personality)]

cat("Secondary variables found in data_personality:", length(existing_secondary_vars), "\n")
if(length(existing_secondary_vars) > 0) {
  cat("Variables found:\n")
  print(existing_secondary_vars)
}

# Add variables back to imputed dataset using the same indexing as before
if(length(existing_secondary_vars) > 0) {
  cat("\n=== ADDING VARIABLES TO IMPUTED DATASET ===\n")
  
  # Use the same valid_outcome_indices from the multiple imputation step
  for(var in existing_secondary_vars) {
    # Get the source data using the same indices as the imputed dataset
    source_data <- data_personality[[var]][valid_outcome_indices]
    
    # Add to imputed dataset
    final_dataset_imputed[[var]] <- source_data
    
    missing_count <- sum(is.na(source_data))
    non_missing <- sum(!is.na(source_data))
    cat(sprintf("Added %s: %d non-missing, %d missing\n", var, non_missing, missing_count))
  }
} else {
  cat("No secondary variables found to add\n")
}

# COMBINE GENDER-SPECIFIC ALCOHOL VARIABLES
cat("\n=== COMBINING GENDER-SPECIFIC ALCOHOL VARIABLES ===\n")
if("alc_use_wmn" %in% names(final_dataset_imputed) && "alc_use_men" %in% names(final_dataset_imputed)) {
  # Create combined alcohol variable based on sex
  # sex = 1 shows alc_use_wmn, sex = 2 shows alc_use_men
  final_dataset_imputed$alc_use_combined <- ifelse(
    final_dataset_imputed$sex == 1, 
    final_dataset_imputed$alc_use_wmn,
    final_dataset_imputed$alc_use_men
  )
  
  # Check the combination worked
  wmn_data_count <- sum(!is.na(final_dataset_imputed$alc_use_wmn))
  men_data_count <- sum(!is.na(final_dataset_imputed$alc_use_men))
  combined_data_count <- sum(!is.na(final_dataset_imputed$alc_use_combined))
  
  cat(sprintf("Original alc_use_wmn: %d non-missing\n", wmn_data_count))
  cat(sprintf("Original alc_use_men: %d non-missing\n", men_data_count))
  cat(sprintf("Combined alc_use_combined: %d non-missing\n", combined_data_count))
  
  # Remove the original gender-specific variables
  final_dataset_imputed$alc_use_wmn <- NULL
  final_dataset_imputed$alc_use_men <- NULL
  
  cat("✓ Gender-specific alcohol variables combined and originals removed\n")
} else {
  cat("Gender-specific alcohol variables not found\n")
}

# Define adverse effects variable pairs for combination
adverse_var_pairs <- list(
  side_effects_1_combined = c("side_effects_1", "side_effects_1_v2"),
  side_effects_2_combined = c("side_effects_2", "side_effects_2_v2"),
  side_effects_3_combined = c("side_effects_3", "side_effects_3_v2"),
  side_effects_4_combined = c("side_effects_4", "side_effects_4_v2"),
  safety_1_combined = c("safety_1", "safety_1_v2"),
  safety_2_combined = c("safety_2", "safety_2_v2"),
  safety_3_combined = c("safety_3", "safety_3_v2"),
  safety_4_combined = c("safety_4", "safety_4_v2"),
  adls_1_combined = c("adls_1", "adls_1_v2"),
  adls_2_combined = c("adls_2", "adls_2_v2"),
  dependence_1_combined = c("dependence_1", "dependence_1_v2"),
  dependence_2_combined = c("dependence_2", "dependence_2_v2"),
  dependence_3_combined = c("dependence_3", "dependence_3_v2")
)

cat("\n=== COMBINING ADVERSE EFFECTS VARIABLES ===\n")

# Track successfully combined variables
combined_adverse_vars_cluster <- character(0)

# Process each adverse effects variable pair
for(combined_name in names(adverse_var_pairs)) {
  current_var <- adverse_var_pairs[[combined_name]][1]
  past_var <- adverse_var_pairs[[combined_name]][2]
  
  cat("Processing", combined_name, "...\n")
  
  current_exists <- current_var %in% names(final_dataset_imputed)
  past_exists <- past_var %in% names(final_dataset_imputed)
  
  if(current_exists && past_exists) {
    # Get the data
    current_data <- final_dataset_imputed[[current_var]]
    past_data <- final_dataset_imputed[[past_var]]
    outcome_data <- final_dataset_imputed$scrn_stopped_bzra
    
    # Create combined variable
    combined_data <- rep(NA, nrow(final_dataset_imputed))
    
    # For current users (scrn_stopped_bzra == 0), use current version
    current_user_indices <- which(outcome_data == 0)
    if(length(current_user_indices) > 0) {
      combined_data[current_user_indices] <- current_data[current_user_indices]
    }
    
    # For past users (scrn_stopped_bzra == 1), use past version  
    past_user_indices <- which(outcome_data == 1)
    if(length(past_user_indices) > 0) {
      combined_data[past_user_indices] <- past_data[past_user_indices]
    }
    
    # Add to dataset
    final_dataset_imputed[[combined_name]] <- combined_data
    combined_adverse_vars_cluster <- c(combined_adverse_vars_cluster, combined_name)
    
    # Remove original versions to avoid confusion
    final_dataset_imputed[[current_var]] <- NULL
    final_dataset_imputed[[past_var]] <- NULL
    
    missing_count <- sum(is.na(combined_data))
    non_missing <- sum(!is.na(combined_data))
    cat(sprintf("✓ Created %s: %d non-missing, %d missing\n", combined_name, non_missing, missing_count))
    
  } else if(current_exists) {
    # Only current version exists
    final_dataset_imputed[[combined_name]] <- final_dataset_imputed[[current_var]]
    final_dataset_imputed[[current_var]] <- NULL
    combined_adverse_vars_cluster <- c(combined_adverse_vars_cluster, combined_name)
    cat(sprintf("✓ Used current version for %s\n", combined_name))
    
  } else if(past_exists) {
    # Only past version exists
    final_dataset_imputed[[combined_name]] <- final_dataset_imputed[[past_var]]
    final_dataset_imputed[[past_var]] <- NULL
    combined_adverse_vars_cluster <- c(combined_adverse_vars_cluster, combined_name)
    cat(sprintf("✓ Used past version for %s\n", combined_name))
    
  } else {
    cat(sprintf("✗ Neither version exists for %s\n", combined_name))
  }
}

# Get substance use variables (updated to include combined alcohol variable)
substance_vars_cluster <- names(final_dataset_imputed)[grepl("alc_|can_|op_|med_|melatonin|quet|traz|otc", names(final_dataset_imputed))]

cat("\n=== CLUSTER ANALYSIS VARIABLES SUMMARY ===\n")
cat("Combined adverse effects variables:", length(combined_adverse_vars_cluster), "\n")
if(length(combined_adverse_vars_cluster) > 0) {
  cat("Adverse effects variables:\n")
  for(var in combined_adverse_vars_cluster) {
    missing_count <- sum(is.na(final_dataset_imputed[[var]]))
    non_missing <- sum(!is.na(final_dataset_imputed[[var]]))
    cat(sprintf("  %s: %d non-missing, %d missing\n", var, non_missing, missing_count))
  }
}

cat("\nSubstance use variables:", length(substance_vars_cluster), "\n")
if(length(substance_vars_cluster) > 0) {
  cat("Substance use variables:\n")
  for(var in substance_vars_cluster) {
    missing_count <- sum(is.na(final_dataset_imputed[[var]]))
    non_missing <- sum(!is.na(final_dataset_imputed[[var]]))
    cat(sprintf("  %s: %d non-missing, %d missing\n", var, non_missing, missing_count))
  }
}

# Create cluster analysis dataset
cat("\n=== CREATING CLUSTER ANALYSIS DATASET ===\n")

# Core variables for cluster analysis (imputed, so complete)
core_cluster_vars <- c(
  # DBAS scales
  "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", "DBAS_Medications",
  # Personality
  "Extraversion", "Agreeableness", "Conscientiousness", "Neuroticism", "Openness",
  # SURPS
  "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", "SURPS_Anxiety_Sensitivity",
  # CISS
  "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
  # Other scales
  "osss_3_score", "phq2_score",
  # Demographics
  "age", "sex",
  # Outcome
  "scrn_stopped_bzra"
)

# Check which core variables exist
existing_core_cluster <- core_cluster_vars[core_cluster_vars %in% names(final_dataset_imputed)]

# Combine all variables for cluster analysis
all_cluster_vars <- c(existing_core_cluster, combined_adverse_vars_cluster, substance_vars_cluster)

# Create cluster analysis dataset with complete cases only for secondary variables
cluster_analysis_data <- final_dataset_imputed %>%
  select(all_of(all_cluster_vars)) %>%
  # Keep all cases for core variables (they're imputed), but require complete cases for secondary variables
  filter(if(length(c(combined_adverse_vars_cluster, substance_vars_cluster)) > 0) {
    complete.cases(select(., all_of(c(combined_adverse_vars_cluster, substance_vars_cluster))))
  } else {
    TRUE
  })

cat("Cluster analysis dataset created:\n")
cat("Total variables:", length(all_cluster_vars), "\n")
cat("- Core variables (imputed):", length(existing_core_cluster), "\n")
cat("- Adverse effects variables:", length(combined_adverse_vars_cluster), "\n") 
cat("- Substance use variables:", length(substance_vars_cluster), "\n")
cat("Complete cases:", nrow(cluster_analysis_data), "out of", nrow(final_dataset_imputed), "total\n")

# Save datasets to global environment
assign("final_dataset_imputed", final_dataset_imputed, envir = .GlobalEnv)
assign("cluster_analysis_data", cluster_analysis_data, envir = .GlobalEnv)
assign("combined_adverse_vars_cluster", combined_adverse_vars_cluster, envir = .GlobalEnv)
assign("substance_vars_cluster", substance_vars_cluster, envir = .GlobalEnv)

cat("\n✓ All variables prepared for cluster analysis\n")
cat("✓ final_dataset_imputed updated with combined variables\n")
cat("✓ cluster_analysis_data ready for cluster analysis\n")

# Final verification
cat("\nFinal dataset dimensions:", nrow(final_dataset_imputed), "x", ncol(final_dataset_imputed), "\n")
cat("Variables available for clustering:\n")
if(length(combined_adverse_vars_cluster) > 0) {
  cat("- Adverse effects (combined):", paste(head(combined_adverse_vars_cluster, 5), collapse = ", "))
  if(length(combined_adverse_vars_cluster) > 5) cat("... and", length(combined_adverse_vars_cluster) - 5, "more")
  cat("\n")
}
if(length(substance_vars_cluster) > 0) {
  cat("- Substance use:", paste(head(substance_vars_cluster, 5), collapse = ", "))
  if(length(substance_vars_cluster) > 5) cat("... and", length(substance_vars_cluster) - 5, "more")
  cat("\n")
}
```


## Data Preperation

The section where I will change some of the variables to different groupings. I will change the regional groupings to regions of the country rather than each province, I will change the educational groupings to simply <High School or Trade/Uni, and I will change employment to Full/Part Time Work or Not Employed/Retired.

```{r}
#| label: Data Preparation for Analysis 
######
# Prepare data with grouped variables
# Variables already detected in previous step
######

library(dplyr)

cat("=== DATA PREPARATION ===\n")
cat("Dataset dimensions:", nrow(final_dataset_imputed), "rows,", ncol(final_dataset_imputed), "columns\n")

# Variables are already set from previous step, just verify
cat("Using variables from secondary analysis step:\n")
cat("- Combined adverse effects variables:", length(combined_adverse_vars), "\n")
cat("- Substance use variables:", length(substance_vars), "\n")
cat("- Final numeric variables:", length(final_numeric_vars), "\n")

# --- Regional groupings ---
if("prov_terr" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$prov_terr_region <- case_when(
    final_dataset_imputed$prov_terr %in% c(1, 2, 3, 12) ~ "Prairies",
    final_dataset_imputed$prov_terr %in% c(9, 11) ~ "Central Canada", 
    final_dataset_imputed$prov_terr %in% c(4, 5, 7, 10) ~ "Atlantic Canada",
    final_dataset_imputed$prov_terr %in% c(6, 8, 13) ~ "Territories",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$prov_terr_region <- factor(final_dataset_imputed$prov_terr_region,
                                                   levels = c("Prairies", "Central Canada", 
                                                              "Atlantic Canada", "Territories"))
  cat("✓ Created regional groupings\n")
}

# --- Education groupings ---
if("education" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$education_level <- case_when(
    final_dataset_imputed$education %in% c(1, 2, 3) ~ "High School or Less",
    final_dataset_imputed$education %in% c(4, 5) ~ "Trade School/University",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$education_level <- factor(final_dataset_imputed$education_level,
                                                  levels = c("High School or Less", "Trade School/University"))
  cat("✓ Created education level groupings\n")
}

# --- Employment groupings ---
if("employment" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$employment_status <- case_when(
    final_dataset_imputed$employment %in% c(0, 3, 4) ~ "Retired/Not in Workforce",
    final_dataset_imputed$employment %in% c(1, 2) ~ "Full- or Part-Time",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$employment_status <- factor(final_dataset_imputed$employment_status,
                                                    levels = c("Full- or Part-Time", "Retired/Not in Workforce"))
  cat("✓ Created employment status groupings\n")
}

# Verify outcome variable is properly coded
if("scrn_stopped_bzra" %in% names(final_dataset_imputed)) {
  cat("\n✓ Outcome variable verification:\n")
  cat("Missing values in scrn_stopped_bzra:", sum(is.na(final_dataset_imputed$scrn_stopped_bzra)), "\n")
  cat("Distribution of scrn_stopped_bzra:\n")
  print(table(final_dataset_imputed$scrn_stopped_bzra, useNA = "ifany"))
}

cat("\nData preparation complete!\n")
```


## Entire Group Descriptives

This section of the code will present all the descriptive statistics for the entire group with the variables about adverse effects, dependence, negative daytime experiences, substance use, sleep-related substance use added to the core personality and demographics data. 

```{r}
#| label: Entire Group Descriptives
######
# This chunk describes the entire sample (no grouping by BZRA status).
# It separates variables into: 
#   1. Continuous
#   2. Ordinal (frequency/attitudes)
#   3. Categorical (demographics)
######

library(dplyr)

cat("=== ENTIRE SAMPLE DESCRIPTIVE STATISTICS ===\n")
cat("Sample size:", nrow(final_dataset_imputed), "\n")

# Identify numeric variables
numeric_vars <- names(final_dataset_imputed)[sapply(final_dataset_imputed, is.numeric)]
# Remove categorical numeric variables (Likert/radio) from numeric summary
categorical_numeric_vars <- c(
  "op_use", "can_use", "alc_sleep", "can_sleep", "melatonin_use", "op_sleep",
  "quet_use", "traz_use", "otc_use",
  "side_effects_1_combined", "side_effects_2_combined", "side_effects_3_combined", "side_effects_4_combined",
  "safety_1_combined", "safety_2_combined", "safety_3_combined", "safety_4_combined",
  "adls_1_combined", "adls_2_combined",
  "dependence_1_combined", "dependence_2_combined", "dependence_3_combined",
  "alc_use_combined"
)
numeric_vars <- setdiff(numeric_vars, categorical_numeric_vars)

# Numeric variables summary
if(length(numeric_vars) > 0) {
  cat("\nNUMERIC VARIABLES:\n")
  for(var in numeric_vars) {
    x <- final_dataset_imputed[[var]]
    cat(var, "-> Mean:", round(mean(x, na.rm=TRUE),2),
        "SD:", round(sd(x, na.rm=TRUE),2),
        "Min:", round(min(x, na.rm=TRUE),2),
        "Max:", round(max(x, na.rm=TRUE),2), "\n")
  }
}

# Automatically identify categorical variables
auto_categorical_vars <- names(final_dataset_imputed)[sapply(final_dataset_imputed, function(x) {
  is.factor(x) || (is.numeric(x) && length(unique(x[!is.na(x)])) <= 6)
})]
# Remove numeric variables
auto_categorical_vars <- setdiff(auto_categorical_vars, numeric_vars)

# Categorical variables summary
cat("\nCATEGORICAL VARIABLES:\n")
for(var in auto_categorical_vars) {
  if(var %in% names(final_dataset_imputed)) {
    cat("\n", var, ":\n")
    counts <- table(final_dataset_imputed[[var]], useNA = "ifany")
    perc <- round(prop.table(counts) * 100, 1)
    for(i in seq_along(counts)) {
      cat("  ", names(counts)[i], ": ", counts[i], " (", perc[i], "%)\n", sep = "")
    }
  }
}

# === ALCOHOL USE DESCRIPTIVES (separate by sex using alc_use_combined) ===
cat("\n--- ALCOHOL USE (separate by sex using alc_use_combined) ---\n")

cat("\nAlcohol Use - Women:\n")
if("alc_use_combined" %in% names(final_dataset_imputed)) {
  counts_w <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 1], useNA = "ifany")
  perc_w <- round(prop.table(counts_w) * 100, 1)
  for(i in seq_along(counts_w)) {
    cat("  ", names(counts_w)[i], ": ", counts_w[i], " (", perc_w[i], "%)\n", sep = "")
  }
}

cat("\nAlcohol Use - Men:\n")
if("alc_use_combined" %in% names(final_dataset_imputed)) {
  counts_m <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 2], useNA = "ifany")
  perc_m <- round(prop.table(counts_m) * 100, 1)
  for(i in seq_along(counts_m)) {
    cat("  ", names(counts_m)[i], ": ", counts_m[i], " (", perc_m[i], "%)\n", sep = "")
  }
}

cat("\n=== DESCRIPTIVES COMPLETE ===\n")
```


## Group Comparison Descriptives

This section will split the groups based on their answer to scrn_stopped_bzra.

```{r}
#| label: Descriptives by BZRA status with effect sizes
#######
# Descriptive statistics for the entire sample, divided by BZRA status
# (scrn_stopped_bzra), including numeric effect sizes (Cohen's d)
#######
library(dplyr)
library(effsize)
cat("=== DESCRIPTIVE STATISTICS BY BZRA STATUS ===\n")
cat("Total sample size:", nrow(final_dataset_imputed), "\n")

# Create group labels using the correct factor levels
current_users <- final_dataset_imputed$scrn_stopped_bzra == "Current Users (0)"
past_users <- final_dataset_imputed$scrn_stopped_bzra == "Past Users (1)"

cat("Current Users (0):", sum(current_users, na.rm = TRUE), "\n")
cat("Past Users (1):", sum(past_users, na.rm = TRUE), "\n\n")

# Identify numeric variables
numeric_vars <- names(final_dataset_imputed)[sapply(final_dataset_imputed, is.numeric)]

# Remove categorical numeric variables (Likert/radio) from numeric summary
categorical_numeric_vars <- c(
  "op_use", "can_use", "alc_sleep", "can_sleep", "melatonin_use", "op_sleep",
  "quet_use", "traz_use", "otc_use",
  "side_effects_1_combined", "side_effects_2_combined", "side_effects_3_combined", "side_effects_4_combined",
  "safety_1_combined", "safety_2_combined", "safety_3_combined", "safety_4_combined",
  "adls_1_combined", "adls_2_combined",
  "dependence_1_combined", "dependence_2_combined", "dependence_3_combined",
  "alc_use_combined"
)
numeric_vars <- setdiff(numeric_vars, categorical_numeric_vars)

# Numeric variables summary by group with effect sizes
if(length(numeric_vars) > 0) {
  cat("=== NUMERIC VARIABLES ===\n")
  for(var in numeric_vars) {
    cat("\n", var, ":\n")
    
    # Current users
    x_current <- final_dataset_imputed[[var]][current_users]
    x_current_clean <- x_current[!is.na(x_current)]
    cat("  Current Users -> Mean:", round(mean(x_current, na.rm=TRUE),2),
        "SD:", round(sd(x_current, na.rm=TRUE),2),
        "Min:", round(min(x_current, na.rm=TRUE),2),
        "Max:", round(max(x_current, na.rm=TRUE),2), "\n")
    
    # Past users
    x_past <- final_dataset_imputed[[var]][past_users]
    x_past_clean <- x_past[!is.na(x_past)]
    cat("  Past Users    -> Mean:", round(mean(x_past, na.rm=TRUE),2),
        "SD:", round(sd(x_past, na.rm=TRUE),2),
        "Min:", round(min(x_past, na.rm=TRUE),2),
        "Max:", round(max(x_past, na.rm=TRUE),2), "\n")
    
    # Effect size and significance test
    if(length(x_current_clean) > 0 & length(x_past_clean) > 0) {
      # Cohen's d
      cohens_d <- tryCatch({
        d_result <- cohen.d(x_past_clean, x_current_clean)
        round(d_result$estimate, 3)
      }, error = function(e) NA)
      
      # t-test
      t_test <- tryCatch({
        t.test(x_past_clean, x_current_clean)
      }, error = function(e) NULL)
      
      p_val <- if(!is.null(t_test)) {
        if(t_test$p.value < 0.001) "< 0.001" else round(t_test$p.value, 4)
      } else NA
      
      cat("  Effect size: Cohen's d =", cohens_d, ", p-value =", p_val, "\n")
    }
  }
}

# Automatically identify categorical variables
auto_categorical_vars <- names(final_dataset_imputed)[sapply(final_dataset_imputed, function(x) {
  is.factor(x) || (is.numeric(x) && length(unique(x[!is.na(x)])) <= 6)
})]

# Remove numeric variables
auto_categorical_vars <- setdiff(auto_categorical_vars, numeric_vars)

# Categorical variables summary by group with effect sizes
cat("\n=== CATEGORICAL VARIABLES ===\n")
for(var in auto_categorical_vars) {
  if(var %in% names(final_dataset_imputed)) {
    cat("\n", var, ":\n")
    
    # Current users
    cat("  Current Users:\n")
    counts_current <- table(final_dataset_imputed[[var]][current_users], useNA = "ifany")
    perc_current <- round(prop.table(counts_current) * 100, 1)
    for(i in seq_along(counts_current)) {
      cat("    ", names(counts_current)[i], ": ", counts_current[i], " (", perc_current[i], "%)\n", sep = "")
    }
    
    # Past users
    cat("  Past Users:\n")
    counts_past <- table(final_dataset_imputed[[var]][past_users], useNA = "ifany")
    perc_past <- round(prop.table(counts_past) * 100, 1)
    for(i in seq_along(counts_past)) {
      cat("    ", names(counts_past)[i], ": ", counts_past[i], " (", perc_past[i], "%)\n", sep = "")
    }
    
    # Effect size for categorical variables
    if(length(counts_current) > 0 & length(counts_past) > 0) {
      # Create contingency table
      cont_table <- tryCatch({
        table(final_dataset_imputed[[var]], final_dataset_imputed$scrn_stopped_bzra)
      }, error = function(e) NULL)
      
      if(!is.null(cont_table) && sum(cont_table) > 0) {
        # Chi-square test
        chi_result <- tryCatch({
          suppressWarnings(chisq.test(cont_table))
        }, error = function(e) NULL)
        
        if(!is.null(chi_result)) {
          p_val <- if(!is.na(chi_result$p.value) && chi_result$p.value < 0.001) {
            "< 0.001" 
          } else if(!is.na(chi_result$p.value)) {
            round(chi_result$p.value, 4)
          } else {
            "NA (insufficient data)"
          }
          
          # Cramér's V (effect size for categorical variables)
          if(!is.na(chi_result$statistic)) {
            cramers_v <- sqrt(chi_result$statistic / (sum(cont_table) * (min(dim(cont_table)) - 1)))
            cat("  Effect size: Cramér's V =", round(cramers_v, 3), ", p-value =", p_val, "\n")
          } else {
            cat("  Effect size: Cannot calculate - insufficient data\n")
          }
        }
      }
    }
  }
}

# === ALCOHOL USE DESCRIPTIVES (separate by sex and BZRA status) ===
cat("\n=== ALCOHOL USE BY SEX AND BZRA STATUS ===\n")

if("alc_use_combined" %in% names(final_dataset_imputed)) {
  # Women - Current Users
  cat("\nAlcohol Use - Women - Current Users:\n")
  counts_w_current <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 1 & current_users], useNA = "ifany")
  perc_w_current <- round(prop.table(counts_w_current) * 100, 1)
  for(i in seq_along(counts_w_current)) {
    cat("  ", names(counts_w_current)[i], ": ", counts_w_current[i], " (", perc_w_current[i], "%)\n", sep = "")
  }
  
  # Women - Past Users
  cat("\nAlcohol Use - Women - Past Users:\n")
  counts_w_past <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 1 & past_users], useNA = "ifany")
  perc_w_past <- round(prop.table(counts_w_past) * 100, 1)
  for(i in seq_along(counts_w_past)) {
    cat("  ", names(counts_w_past)[i], ": ", counts_w_past[i], " (", perc_w_past[i], "%)\n", sep = "")
  }
  
  # Men - Current Users
  cat("\nAlcohol Use - Men - Current Users:\n")
  counts_m_current <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 2 & current_users], useNA = "ifany")
  perc_m_current <- round(prop.table(counts_m_current) * 100, 1)
  for(i in seq_along(counts_m_current)) {
    cat("  ", names(counts_m_current)[i], ": ", counts_m_current[i], " (", perc_m_current[i], "%)\n", sep = "")
  }
  
  # Men - Past Users
  cat("\nAlcohol Use - Men - Past Users:\n")
  counts_m_past <- table(final_dataset_imputed$alc_use_combined[final_dataset_imputed$sex == 2 & past_users], useNA = "ifany")
  perc_m_past <- round(prop.table(counts_m_past) * 100, 1)
  for(i in seq_along(counts_m_past)) {
    cat("  ", names(counts_m_past)[i], ": ", counts_m_past[i], " (", perc_m_past[i], "%)\n", sep = "")}}

# Statistical tests for alcohol use - Current vs Past Users by sex
  # Women: Current vs Past Users
  women_data <- final_dataset_imputed[final_dataset_imputed$sex == 1 & !is.na(final_dataset_imputed$alc_use_combined), ]
  cont_table_women <- table(women_data$alc_use_combined, women_data$scrn_stopped_bzra)
  chi_result_women <- tryCatch(suppressWarnings(chisq.test(cont_table_women)), error = function(e) NULL)
  if(!is.null(chi_result_women) && !is.na(chi_result_women$statistic)) {
    p_val <- if(chi_result_women$p.value < 0.001) "< 0.001" else round(chi_result_women$p.value, 4)
    cramers_v <- sqrt(chi_result_women$statistic / (sum(cont_table_women) * (min(dim(cont_table_women)) - 1)))
    cat("  Women - Current vs Past Users: Cramér's V =", round(cramers_v, 3), ", p-value =", p_val, "\n")}
  
  # Men: Current vs Past Users
  men_data <- final_dataset_imputed[final_dataset_imputed$sex == 2 & !is.na(final_dataset_imputed$alc_use_combined), ]
  cont_table_men <- table(men_data$alc_use_combined, men_data$scrn_stopped_bzra)
  chi_result_men <- tryCatch(suppressWarnings(chisq.test(cont_table_men)), error = function(e) NULL)
  if(!is.null(chi_result_men) && !is.na(chi_result_men$statistic)) {
    p_val <- if(chi_result_men$p.value < 0.001) "< 0.001" else round(chi_result_men$p.value, 4)
    cramers_v <- sqrt(chi_result_men$statistic / (sum(cont_table_men) * (min(dim(cont_table_men)) - 1)))
    cat("  Men - Current vs Past Users: Cramér's V =", round(cramers_v, 3), ", p-value =", p_val, "\n")}

cat("\n=== DESCRIPTIVES BY BZRA STATUS COMPLETE ===\n")
```


## Random Forest Model 

This section of the code will be used for the Random Forest Model 
to help identify the most important predictors of the outcome variable, 
assist with regression variable selection, evaluate model performance, and generate predictions.

```{r}
#| label: Random Forest Model
######
#
#
######

```









## Cluster Analysis For Personality and Demographics

This section will be used for my cluster analysis. I will start by removing the outcome variable and then running a cluster analysis only on the personality/demographic variables to see what emerges from that.

```{r}
#| label: Cluster Analysis
######
# UNSUPERVISED CLUSTER ANALYSIS - OUTCOME-AGNOSTIC APPROACH
# Remove outcome variable to allow natural phenotype discovery
######

# === ENHANCED CLUSTERING WITH COMPLETE DEMOGRAPHIC VARIABLES ===
cat("=== ENHANCED CLUSTERING WITH COMPLETE DEMOGRAPHICS ===\n")
cat("Outcome-agnostic approach with expanded demographic variables\n\n")

# Load required libraries
library(cluster)
library(factoextra)
library(dplyr)
library(tidyr)

# === DEFINE EXPANDED CLUSTERING VARIABLES ===
cat("=== VARIABLE COMPLETENESS CHECK ===\n")

# Core complete variables including expanded demographics
core_clustering_vars <- c(
  # DBAS scales
  "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", "DBAS_Medications",
  # Personality
  "Extraversion", "Agreeableness", "Conscientiousness", "Neuroticism", "Openness",
  # SURPS
  "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", "SURPS_Anxiety_Sensitivity",
  # CISS
  "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
  # Other complete scales
  "osss_3_score", "phq2_score",
  # Demographics - expanded
  "age", "sex", "gender", "prov_terr_region", "education_level", 
  "employment_status", "driving_freq", "income"
)

# Check which variables actually exist in the dataset
available_vars <- core_clustering_vars[core_clustering_vars %in% names(final_dataset_imputed)]
missing_vars <- core_clustering_vars[!core_clustering_vars %in% names(final_dataset_imputed)]

if(length(missing_vars) > 0) {
  cat("Variables not found in dataset:", paste(missing_vars, collapse = ", "), "\n")
}
cat("Available variables:", length(available_vars), "out of", length(core_clustering_vars), "\n")

# Handle prov_terr_region missing data (if it exists)
if("prov_terr_region" %in% available_vars) {
  missing_prov_count <- sum(is.na(final_dataset_imputed$prov_terr_region))
  if(missing_prov_count > 0) {
    cat("Found", missing_prov_count, "missing prov_terr_region values\n")
    
    # Impute with mode (most common province/territory)
    mode_prov <- names(sort(table(final_dataset_imputed$prov_terr_region, useNA = "no"), 
                           decreasing = TRUE))[1]
    final_dataset_imputed$prov_terr_region[is.na(final_dataset_imputed$prov_terr_region)] <- mode_prov
    
    cat("✓ Imputed missing prov_terr_region with mode:", mode_prov, "\n")
  }
}
cat("\n")

# Check completeness of available variables
completeness_check <- final_dataset_imputed %>%
  select(all_of(available_vars)) %>%
  summarise_all(~sum(is.na(.))) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "missing_count") %>%
  mutate(
    total_n = nrow(final_dataset_imputed),
    percent_missing = round(missing_count / total_n * 100, 1),
    complete = missing_count == 0
  ) %>%
  arrange(percent_missing)

cat("Variable completeness summary:\n")
print(completeness_check)

# Filter to only truly complete variables
truly_complete_vars <- completeness_check %>%
  filter(complete == TRUE) %>%
  pull(variable)

cat("\n✓ Truly complete variables:", length(truly_complete_vars), "\n")
cat("Complete variables:", paste(truly_complete_vars, collapse = ", "), "\n\n")

# === CREATE CLUSTERING DATASET ===
cat("=== CREATING CLUSTERING DATASET ===\n")

# Create clustering dataset with proper handling of categorical variables
# Identify which categorical variables are actually present
potential_cat_vars <- c("sex", "gender", "prov_terr_region", "education_level", 
                       "employment_status", "driving_freq", "income")
actual_cat_vars <- intersect(potential_cat_vars, truly_complete_vars)

cat("Categorical variables found:", paste(actual_cat_vars, collapse = ", "), "\n")

core_cluster_data <- final_dataset_imputed %>%
  select(all_of(truly_complete_vars)) %>%
  # Convert categorical variables to factors if they exist
  {if(length(actual_cat_vars) > 0) 
    mutate(., across(all_of(actual_cat_vars), as.factor)) 
   else .} %>%
  filter(complete.cases(.))

cat("✓ Clustering dataset:", nrow(core_cluster_data), "participants x", ncol(core_cluster_data), "variables\n")

# Check data types
cat("\nData types:\n")
sapply(core_cluster_data, class) %>% print()

# === MIXED-DATA CLUSTERING WITH GOWER DISTANCE ===
cat("\n=== MIXED-DATA CLUSTERING (GOWER DISTANCE + PAM) ===\n")

# Calculate Gower distance (handles mixed data types)
cat("Calculating Gower distance matrix...\n")
gower_dist <- daisy(core_cluster_data, metric = "gower")
cat("✓ Distance matrix computed\n")

# === DETERMINE OPTIMAL NUMBER OF CLUSTERS ===
cat("\n=== OPTIMAL NUMBER OF CLUSTERS (PAM + SILHOUETTE) ===\n")

max_k <- min(10, floor(sqrt(nrow(core_cluster_data)/2)))
cat("Testing k from 2 to", max_k, "\n")

# Silhouette method for PAM
silhouette_scores_pam <- numeric(max_k-1)
cat("Silhouette scores:\n")
for(k in 2:max_k) {
  pam_result <- pam(gower_dist, k = k)
  sil_score <- pam_result$silinfo$avg.width
  silhouette_scores_pam[k-1] <- sil_score
  cat(sprintf("  k=%d: Avg Silhouette=%.3f\n", k, sil_score))
}

# Find optimal k
optimal_k_pam <- which.max(silhouette_scores_pam) + 1
cat(sprintf("\n✓ Optimal k by Silhouette: %d (score=%.3f)\n", optimal_k_pam, max(silhouette_scores_pam)))

# === FINAL CLUSTERING ===
cat("\n=== FINAL PAM CLUSTERING ===\n")

final_k <- optimal_k_pam
cat("Using k =", final_k, "clusters\n")

# Perform final clustering
final_pam <- pam(gower_dist, k = final_k)

cat("Clustering results:\n")
cat("  Average Silhouette Width:", round(final_pam$silinfo$avg.width, 3), "\n")

# Cluster sizes
cat("  Cluster sizes:\n")
cluster_sizes <- table(final_pam$clustering)
for(i in 1:final_k) {
  cat(sprintf("    Cluster %d: n=%d (%.1f%%)\n", 
              i, cluster_sizes[i], cluster_sizes[i]/sum(cluster_sizes)*100))
}

# === CLUSTER VALIDATION ===
cat("\n=== CLUSTER VALIDATION ===\n")

avg_sil_width <- final_pam$silinfo$avg.width
cat("Average Silhouette Width:", round(avg_sil_width, 3), "\n")

if(avg_sil_width > 0.5) {
  cat("✓ Good cluster structure\n")
} else if(avg_sil_width > 0.25) {
  cat("⚠️  Moderate cluster structure\n")
} else {
  cat("⚠️  Weak cluster structure\n")
}

# === ALTERNATIVE: K-MEANS WITH DUMMY VARIABLES ===
cat("\n=== ALTERNATIVE: K-MEANS WITH DUMMY VARIABLES ===\n")

# Identify categorical variables
cat_vars <- sapply(core_cluster_data, is.factor)
if(any(cat_vars)) {
  cat("Creating dummy variables for categorical predictors...\n")
  
  # Create dummy variables using base R (no additional package needed)
  # Convert factors to dummy variables manually
  numeric_data <- core_cluster_data %>%
    select_if(is.numeric)
  
  categorical_data <- core_cluster_data %>%
    select_if(is.factor)
  
  # Create dummy variables for each categorical variable
  dummy_list <- list()
  for(var_name in names(categorical_data)) {
    var_levels <- levels(categorical_data[[var_name]])
    # Create dummy variables (excluding first level to avoid multicollinearity)
    for(level in var_levels[-1]) {
      dummy_name <- paste0(var_name, "_", level)
      dummy_list[[dummy_name]] <- as.numeric(categorical_data[[var_name]] == level)
    }
  }
  
  # Combine numeric and dummy variables
  if(length(dummy_list) > 0) {
    dummy_df <- do.call(cbind, dummy_list) %>% as.data.frame()
    core_cluster_data_dummies <- cbind(numeric_data, dummy_df) %>%
      scale()
  } else {
    core_cluster_data_dummies <- numeric_data %>%
      scale()
  }
  
  # K-means clustering
  set.seed(123)
  kmeans_result <- kmeans(core_cluster_data_dummies, centers = final_k, nstart = 50, iter.max = 300)
  
  # Calculate silhouette for k-means
  sil_kmeans <- silhouette(kmeans_result$cluster, dist(core_cluster_data_dummies))
  avg_sil_kmeans <- mean(sil_kmeans[,3])
  
  cat("K-means results:\n")
  cat("  Average Silhouette Width:", round(avg_sil_kmeans, 3), "\n")
  cat("  Total WSS:", round(kmeans_result$tot.withinss, 2), "\n")
  cat("  Between SS / Total SS:", round(kmeans_result$betweenss/kmeans_result$totss * 100, 1), "%\n")
  
  # Cluster sizes
  cat("  Cluster sizes:\n")
  kmeans_sizes <- table(kmeans_result$cluster)
  for(i in 1:final_k) {
    cat(sprintf("    Cluster %d: n=%d (%.1f%%)\n", 
                i, kmeans_sizes[i], kmeans_sizes[i]/sum(kmeans_sizes)*100))
  }
  
  cat("\n=== METHOD COMPARISON ===\n")
  cat("PAM (Gower distance)  - Silhouette:", round(avg_sil_width, 3), "\n")
  cat("K-means (dummy vars)  - Silhouette:", round(avg_sil_kmeans, 3), "\n")
  
  # Choose best method
  if(avg_sil_width >= avg_sil_kmeans) {
    cat("✓ Using PAM clustering (better silhouette)\n")
    final_cluster_method <- "PAM"
    final_clusters <- final_pam$clustering
  } else {
    cat("✓ Using K-means clustering (better silhouette)\n")
    final_cluster_method <- "K-means"
    final_clusters <- kmeans_result$cluster
  }
} else {
  cat("No categorical variables found, using PAM results\n")
  final_cluster_method <- "PAM"
  final_clusters <- final_pam$clustering
}

# === SAVE RESULTS ===
cat("\n=== SAVING RESULTS ===\n")

# Add cluster assignments to main dataset
final_dataset_imputed$cluster_assignment_enhanced <- NA
complete_rows <- complete.cases(final_dataset_imputed[, truly_complete_vars])
final_dataset_imputed$cluster_assignment_enhanced[complete_rows] <- final_clusters

# Save to global environment
assign("core_cluster_data", core_cluster_data, envir = .GlobalEnv)
assign("final_pam", final_pam, envir = .GlobalEnv)
assign("truly_complete_vars", truly_complete_vars, envir = .GlobalEnv)
assign("gower_dist", gower_dist, envir = .GlobalEnv)

if(exists("kmeans_result")) {
  assign("kmeans_result_enhanced", kmeans_result, envir = .GlobalEnv)
}

# Final summary
assignment_summary <- final_dataset_imputed %>%
  count(cluster_assignment_enhanced, name = "n") %>%
  mutate(percent = round(n/sum(n)*100, 1)) %>%
  arrange(cluster_assignment_enhanced)

cat("Final cluster assignment summary:\n")
print(assignment_summary)

cat("\n✓ Enhanced clustering analysis complete\n")
cat("✓ Method used:", final_cluster_method, "\n")
cat("✓ Variables used:", length(truly_complete_vars), "\n")
cat("✓ Cluster assignments saved to final_dataset_imputed$cluster_assignment_enhanced\n")
cat("✓ Ready for cluster characterization and outcome validation\n")
```




