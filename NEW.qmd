---
title: "NEW"
author: "PO Couture"
format: html
editor: visual
---

##  New

I will use this document to work on my SIMOA code since I am having trouble with it currently in the existing format. In this way I can mess around with this code and not be worried about it impacting my original data and now that I know what I want to do for my clusters it is easier for me to manipulate the variables in a manner that will set me up for success later.

## Loading the Data

The section I will use to load the dataset that I will use for the analysis.

```{r}
#| label: Loading the Data and Libraries
######
# Loading the data
######

library(readr)
SIMOA <- read_csv("SIMOA Report.csv")
#View(SIMOA)
```

## Eligible Participants

The section where I have set out the inclusion criteria to remove people from the dataset that do not meet our criteria.

```{r}
#| label: Eligible Participants
######
# In this section I will filter out those who have indicated they are <65 or that have not answered   
# yes to the question about age category or not answered either question. I will also filter out those 
# who did not select one of the 14 BZRAs listed because we do not want the results to be affected by 
# other sedating medications such as antihistamines or SSRI's.
# Additionally, filter to include only those who answered the scrn_stopped_bzra question.
######

# Original count
n_original <- nrow(SIMOA)

# After age filtering
SIMOA_age_filtered <- SIMOA %>%
  filter(age_cat == 1 | (age_cat == 0 & age >= 65))
n_after_age <- nrow(SIMOA_age_filtered)

# After c_sp filtering
SIMOA_c_sp_filtered <- SIMOA_age_filtered %>%
  filter(rowSums(select(., starts_with("c_sp___"))[, 1:14] == 1, na.rm = TRUE) > 0)
n_after_c_sp <- nrow(SIMOA_c_sp_filtered)

# After sfrn_stopped_bzra filtering (only those who answered the question)
SIMOA <- SIMOA_c_sp_filtered %>%
  filter(!is.na(scrn_stopped_bzra))
n_final <- nrow(SIMOA)

# Report results
cat("Original sample:", n_original, "\n")
cat("After age filtering:", n_after_age, "(removed:", n_original - n_after_age, ")\n")
cat("After c_sp filtering:", n_after_c_sp, "(removed:", n_after_age - n_after_c_sp, ")\n")
cat("After sfrn_stopped_bzra filtering:", n_final, "(removed:", n_after_c_sp - n_final, ")\n")
cat("Total removed:", n_original - n_final, "\n")
```


## Calculating Subscale Scores

The section where I go about calculating the subscale scores for all the measures and ensure that this is properly done and that way I can compare the groups in subscales rather than the full measure and it makes it easier to report.

```{r}
#| label: Subscale Scores
######
# In this section I will get the subscale scores for all the measures I # have used. I will also ensure that items are appropriately            # reverse-coded.
# All subscale score coding will be found in this chunk but I have      # divided them to make them easy to find. I would rather have 1 chunk   # that way it cuts down on the amount of space being taken up for this  # step.
######

# First, let's create a working copy
data_personality <- SIMOA

######
# BFI-10 SUBSCALE SCORES
######

# Items to reverse: reserved, find_fault, lazy, relaxed, few_interests
# Formula: reversed_score = 6 - original_score
data_personality <- data_personality %>%
  mutate(
    reserved_rev = 6 - reserved,
    find_fault_rev = 6 - find_fault,
    lazy_rev = 6 - lazy,
    relaxed_rev = 6 - relaxed,
    few_interests_rev = 6 - few_interests
  )

# Verifying Reverse-Coding
data_personality %>%
  select(reserved, reserved_rev, find_fault, find_fault_rev, lazy, lazy_rev, 
         relaxed, relaxed_rev, few_interests, few_interests_rev) %>%
  head(10)

# Verify the math: original + reversed should equal 6
verification_check <- data_personality %>%
  mutate(
    reserved_sum = reserved + reserved_rev,
    find_fault_sum = find_fault + find_fault_rev,
    lazy_sum = lazy + lazy_rev,
    relaxed_sum = relaxed + relaxed_rev,
    few_interests_sum = few_interests + few_interests_rev
  ) %>%
  select(ends_with("_sum"))

cat("BFI-10 Reverse coding verification (all should equal 6):\n")
summary(verification_check)

# Creating personality total scores
data_personality <- data_personality %>%
  mutate(
    # Extraversion: reserved (reversed) + outgoing
    Extraversion = reserved_rev + outgoing,
    
    # Agreeableness: trusting + find_fault (reversed)
    Agreeableness = trusting + find_fault_rev,
    
    # Conscientiousness: lazy (reversed) + thorough
    Conscientiousness = lazy_rev + thorough,
    
    # Neuroticism: relaxed (reversed) + nervous
    Neuroticism = relaxed_rev + nervous,
    
    # Openness: few_interests (reversed) + imagination
    Openness = few_interests_rev + imagination
  )

######
# SURPS SUBSCALE SCORES
######

# First, reverse code SURPS Hopelessness items (all except surps17)
# Formula for 1-4 scale: reversed_score = 5 - original_score
data_personality <- data_personality %>%
  mutate(
    surps1_rev = 5 - surps1,
    surps4_rev = 5 - surps4,
    surps7_rev = 5 - surps7,
    surps13_rev = 5 - surps13,
    surps20_rev = 5 - surps20,
    surps23_rev = 5 - surps23
    # Note: surps17 is NOT reversed
  )

# Quick verification - all sums should equal 5
cat("SURPS reverse coding verification (all should equal 5):\n")
print(unique(data_personality$surps1 + data_personality$surps1_rev))
print(unique(data_personality$surps4 + data_personality$surps4_rev))
print(unique(data_personality$surps7 + data_personality$surps7_rev))

# Create SURPS total scores
data_personality <- data_personality %>%
  mutate(
    # Impulsivity: surps2, surps5, surps11, surps15, surps22
    SURPS_Impulsivity = surps2 + surps5 + surps11 + surps15 + surps22,
    
    # Sensation Seeking: surps3, surps6, surps9, surps12, surps16, surps19
    SURPS_Sensation_Seeking = surps3 + surps6 + surps9 + surps12 + surps16 + surps19,
    
    # Hopelessness: surps1(rev), surps4(rev), surps7(rev), surps13(rev), surps17, surps20(rev), surps23(rev)
    SURPS_Hopelessness = surps1_rev + surps4_rev + surps7_rev + surps13_rev + surps17 + surps20_rev + surps23_rev,
    
    # Anxiety Sensitivity: surps8, surps10, surps14, surps18, surps21
    SURPS_Anxiety_Sensitivity = surps8 + surps10 + surps14 + surps18 + surps21
  )

######
# DBAS SUBSCALE SCORES
######

# Response scale: 0-10 (0 = Strongly Disagree, 10 = Strongly Agree)
# No reverse coding needed for DBAS-16
data_personality <- data_personality %>%
  mutate(
    # Expectations subscale (2 items)
    DBAS_Expectations = rowMeans(select(., dbas1, dbas_2), na.rm = TRUE),
    
    # Medications subscale (3 items) 
    DBAS_Medications = rowMeans(select(., dbas_6, dbas_13, dbas_15), na.rm = TRUE),
    
    # Worry/Helplessness subscale (6 items)
    DBAS_Worry_Helplessness = rowMeans(select(., dbas_3, dbas_4, dbas_8, dbas_10, dbas_11, dbas_14), na.rm = TRUE),
    
    # Consequences subscale (5 items)
    DBAS_Consequences = rowMeans(select(., dbas_5, dbas_7, dbas_9, dbas_12, dbas_16), na.rm = TRUE)
  )

# DBAS verification
cat("DBAS-16 Subscale Summary:\n")
data_personality %>%
  select(DBAS_Expectations, DBAS_Medications, DBAS_Worry_Helplessness, DBAS_Consequences) %>%
  summary()

######
# CISS SUBSCALE SCORES
######

data_personality <- data_personality %>%
  mutate(
    # Avoidance Style: ciss1, ciss4, ciss7, ciss9, ciss15, ciss18, ciss21
    CISS_Avoidance_Style = ciss1 + ciss4 + ciss7 + ciss9 + ciss15 + ciss18 + ciss21,
    
    # Task Style: ciss2, ciss6, ciss8, ciss11, ciss13, ciss16, ciss19
    CISS_Task_Style = ciss2 + ciss6 + ciss8 + ciss11 + ciss13 + ciss16 + ciss19,
    
    # Emotional Style: ciss3, ciss5, ciss10, ciss12, ciss14, ciss17, ciss20
    CISS_Emotional_Style = ciss3 + ciss5 + ciss10 + ciss12 + ciss14 + ciss17 + ciss20
  )

# Calculate DBAS total score (sum of all subscales)
data_personality <- data_personality %>%
  mutate(
    # Total DBAS score (sum of all 4 subscales)
    dbas_score = DBAS_Expectations + DBAS_Medications + DBAS_Worry_Helplessness + DBAS_Consequences
  )

# Verification for DBAS total score
cat("DBAS Total Score Summary:\n")
summary(data_personality$dbas_score)
cat("Expected range: 0-10 (average of subscales) or sum of raw items\n\n")
```


## Data Preperation

This section prepare the data for MI and only include those with a complete scrn_stopped_bzra
```{r}
#| label: Data Preparation for Multiple Imputation
######
# Prepare data_personality dataset for multiple imputation
# Include specific variables and create combined adverse effects variables
######

library(dplyr)
library(mice)

cat("=== DATA PREPARATION FOR MULTIPLE IMPUTATION ===\n")

# Start with data_personality dataset
cat("Original data_personality size:", nrow(data_personality), "\n")
cat("Cases with missing scrn_stopped_bzra:", sum(is.na(data_personality$scrn_stopped_bzra)), "\n")

# Filter to only include cases where scrn_stopped_bzra is not NA
data_personality <- data_personality[!is.na(data_personality$scrn_stopped_bzra), ]
cat("Valid outcome cases included:", nrow(data_personality), "\n")

# Verify outcome variable distribution
cat("scrn_stopped_bzra distribution:\n")
print(table(data_personality$scrn_stopped_bzra, useNA = "ifany"))

######
# CREATE COMBINED ADVERSE EFFECTS VARIABLES
######

cat("\n=== CREATING COMBINED ADVERSE EFFECTS VARIABLES ===\n")

# Define adverse effects variable pairs for combination
adverse_var_pairs <- list(
  side_effects_1_combined = c("side_effects_1", "side_effects_1_v2"),
  side_effects_2_combined = c("side_effects_2", "side_effects_2_v2"),
  side_effects_3_combined = c("side_effects_3", "side_effects_3_v2"),
  side_effects_4_combined = c("side_effects_4", "side_effects_4_v2"),
  safety_1_combined = c("safety_1", "safety_1_v2"),
  safety_2_combined = c("safety_2", "safety_2_v2"),
  safety_3_combined = c("safety_3", "safety_3_v2"),
  safety_4_combined = c("safety_4", "safety_4_v2"),
  adls_1_combined = c("adls_1", "adls_1_v2"),
  adls_2_combined = c("adls_2", "adls_2_v2"),
  dependence_1_combined = c("dependence_1", "dependence_1_v2"),
  dependence_2_combined = c("dependence_2", "dependence_2_v2"),
  dependence_3_combined = c("dependence_3", "dependence_3_v2")
)

# Create combined variables by taking the first non-missing value
for(combined_var in names(adverse_var_pairs)) {
  var1 <- adverse_var_pairs[[combined_var]][1]
  var2 <- adverse_var_pairs[[combined_var]][2]
  
  if(var1 %in% names(data_personality) && var2 %in% names(data_personality)) {
    # Create combined variable: use var1 if not missing, otherwise use var2
    data_personality[[combined_var]] <- ifelse(
      !is.na(data_personality[[var1]]), 
      data_personality[[var1]], 
      data_personality[[var2]]
    )
    cat("Created:", combined_var, "from", var1, "and", var2, "\n")
  } else if(var1 %in% names(data_personality)) {
    # Only var1 exists
    data_personality[[combined_var]] <- data_personality[[var1]]
    cat("Created:", combined_var, "from", var1, "only\n")
  } else if(var2 %in% names(data_personality)) {
    # Only var2 exists
    data_personality[[combined_var]] <- data_personality[[var2]]
    cat("Created:", combined_var, "from", var2, "only\n")
  } else {
    cat("Warning: Neither", var1, "nor", var2, "found in dataset\n")
  }
}

######
# DEFINE VARIABLES FOR ANALYSIS
######

cat("\n=== SELECTING VARIABLES FOR ANALYSIS ===\n")

# Core variables requested
core_vars <- c(
  "age", "sex", "gender",
  "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", "DBAS_Medications", "dbas_score",
  "Openness", "Conscientiousness", "Extraversion", "Agreeableness", "Neuroticism",
  "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", "SURPS_Anxiety_Sensitivity",
  "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
  "osss_3_score", "phq2_score",
  "prov_terr", "education", "employment", "driving_freq", "income",
  "med_quant", "med_burden_1", "med_burden2", "medburden_3", "med_burden_4",
  "op_use", "can_use", "caf_use", "nico_use", "alc_sleep", "can_sleep", "melatonin_use", "op_sleep", "quet_use", "traz_use", "otc_use",
  "alc_use_wmn", "alc_use_men"
)

# Combined adverse effects variables
combined_vars <- names(adverse_var_pairs)

# All variables for analysis
all_analysis_vars <- c(core_vars, combined_vars)

cat("Total variables requested:", length(all_analysis_vars), "\n")

######
# CHECK VARIABLE AVAILABILITY AND CREATE SUBSET
######

# Check which variables are available
available_vars <- all_analysis_vars[all_analysis_vars %in% names(data_personality)]
missing_vars <- all_analysis_vars[!all_analysis_vars %in% names(data_personality)]

cat("Variables available:", length(available_vars), "\n")
cat("Variables not found:", length(missing_vars), "\n")

if(length(missing_vars) > 0) {
  cat("\nMissing variables:\n")
  for(var in missing_vars) {
    cat("  -", var, "\n")
  }
}

# Create analysis dataset with available variables
final_dataset_imputed <- data_personality[, available_vars, drop = FALSE]

######
# HANDLE CONDITIONAL SUBSTANCE USE VARIABLES
######

cat("\n=== HANDLING CONDITIONAL SUBSTANCE USE VARIABLES ===\n")

# These variables were only shown to participants who selected them in previous questions
# NA means they never use these substances, so recode NA to 0 ("Never")
conditional_vars <- c("op_use", "can_use", "caf_use", "nico_use", "alc_sleep", "can_sleep", "melatonin_use", "op_sleep", "quet_use", "traz_use", "otc_use")

for(var in conditional_vars) {
  if(var %in% names(final_dataset_imputed)) {
    original_na_count <- sum(is.na(final_dataset_imputed[[var]]))
    
    # Recode NA to 0 (Never used)
    final_dataset_imputed[[var]][is.na(final_dataset_imputed[[var]])] <- 0
    
    cat("Recoded", original_na_count, "NA values to 0 ('Never') for", var, "\n")
  }
}

######
# HANDLE SEX-SPECIFIC ALCOHOL USE VARIABLES - ENFORCE MUTUAL EXCLUSIVITY
######

cat("\n=== HANDLING SEX-SPECIFIC ALCOHOL USE VARIABLES ===\n")

# CRITICAL: alc_use_wmn should ONLY have values for women (sex = 1)
#           alc_use_men should ONLY have values for men (sex = 2)
#           This ensures mutual exclusivity

if("alc_use_wmn" %in% names(final_dataset_imputed) && "sex" %in% names(final_dataset_imputed)) {
  # For women (sex = 1): Keep their actual values as-is (including true missing data)
  # For men (sex = 2): Set ALL values to NA (they should never have answered this)
  
  men_with_wmn_data <- sum(!is.na(final_dataset_imputed$alc_use_wmn) & final_dataset_imputed$sex == 2, na.rm = TRUE)
  if(men_with_wmn_data > 0) {
    cat("⚠ WARNING: Found", men_with_wmn_data, "men with alc_use_wmn data - setting to NA\n")
  }
  
  final_dataset_imputed$alc_use_wmn[final_dataset_imputed$sex == 2] <- NA
  
  # Report missing data in women (true missing that needs imputation)
  women_na_count <- sum(is.na(final_dataset_imputed$alc_use_wmn) & final_dataset_imputed$sex == 1, na.rm = TRUE)
  women_total <- sum(final_dataset_imputed$sex == 1, na.rm = TRUE)
  cat("alc_use_wmn - Women (sex=1): ", women_na_count, " missing out of ", women_total, 
      " (", round(100*women_na_count/women_total, 1), "%)\n", sep="")
  cat("alc_use_wmn - Men (sex=2): All set to NA (mutually exclusive)\n")
}

if("alc_use_men" %in% names(final_dataset_imputed) && "sex" %in% names(final_dataset_imputed)) {
  # For men (sex = 2): Keep their actual values as-is (including true missing data)
  # For women (sex = 1): Set ALL values to NA (they should never have answered this)
  
  women_with_men_data <- sum(!is.na(final_dataset_imputed$alc_use_men) & final_dataset_imputed$sex == 1, na.rm = TRUE)
  if(women_with_men_data > 0) {
    cat("⚠ WARNING: Found", women_with_men_data, "women with alc_use_men data - setting to NA\n")
  }
  
  final_dataset_imputed$alc_use_men[final_dataset_imputed$sex == 1] <- NA
  
  # Report missing data in men (true missing that needs imputation)
  men_na_count <- sum(is.na(final_dataset_imputed$alc_use_men) & final_dataset_imputed$sex == 2, na.rm = TRUE)
  men_total <- sum(final_dataset_imputed$sex == 2, na.rm = TRUE)
  cat("alc_use_men - Men (sex=2): ", men_na_count, " missing out of ", men_total, 
      " (", round(100*men_na_count/men_total, 1), "%)\n", sep="")
  cat("alc_use_men - Women (sex=1): All set to NA (mutually exclusive)\n")
}

# Verify mutual exclusivity
if("alc_use_wmn" %in% names(final_dataset_imputed) && "alc_use_men" %in% names(final_dataset_imputed)) {
  both_present <- sum(!is.na(final_dataset_imputed$alc_use_wmn) & !is.na(final_dataset_imputed$alc_use_men))
  cat("\n✓ VERIFICATION: Cases with both alc_use_wmn AND alc_use_men:", both_present, "\n")
  
  if(both_present > 0) {
    cat("⚠ ERROR: Mutual exclusivity NOT achieved!\n")
  } else {
    cat("✓ SUCCESS: Mutual exclusivity confirmed - no participant has values in both variables\n")
  }
}

# Create a combined alcohol use variable for descriptive purposes only (NOT for imputation)
if("alc_use_wmn" %in% names(final_dataset_imputed) && "alc_use_men" %in% names(final_dataset_imputed) && "sex" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$alc_use_combined <- case_when(
    final_dataset_imputed$sex == 1 ~ final_dataset_imputed$alc_use_wmn,  # Use women's scale for women
    final_dataset_imputed$sex == 2 ~ final_dataset_imputed$alc_use_men,  # Use men's scale for men
    TRUE ~ NA_real_
  )
  cat("Created combined alcohol use variable (alc_use_combined) for descriptive purposes\n")
  cat("NOTE: alc_use_combined will be REMOVED before imputation to avoid redundancy\n")
}

######
# CREATE REGIONAL, EDUCATION, AND EMPLOYMENT GROUPINGS
######

cat("\n=== CREATING DEMOGRAPHIC GROUPINGS ===\n")

# Regional groupings
if("prov_terr" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$prov_terr_region <- case_when(
    final_dataset_imputed$prov_terr %in% c(1, 2, 3, 12) ~ "Prairies",
    final_dataset_imputed$prov_terr %in% c(9, 11) ~ "Central Canada", 
    final_dataset_imputed$prov_terr %in% c(4, 5, 7, 10) ~ "Atlantic Canada",
    final_dataset_imputed$prov_terr %in% c(6, 8, 13) ~ "Territories",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$prov_terr_region <- factor(final_dataset_imputed$prov_terr_region,
                                                   levels = c("Prairies", "Central Canada", 
                                                              "Atlantic Canada", "Territories"))
  cat("Created regional groupings from prov_terr\n")
}

# Education groupings
if("education" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$education_level <- case_when(
    final_dataset_imputed$education %in% c(1, 2, 3) ~ "High School or Less",
    final_dataset_imputed$education %in% c(4, 5) ~ "Trade School/University",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$education_level <- factor(final_dataset_imputed$education_level,
                                                  levels = c("High School or Less", "Trade School/University"))
  cat("Created education level groupings from education\n")
}

# Employment groupings
if("employment" %in% names(final_dataset_imputed)) {
  final_dataset_imputed$employment_status <- case_when(
    final_dataset_imputed$employment %in% c(0, 3, 4) ~ "Retired/Not in Workforce",
    final_dataset_imputed$employment %in% c(1, 2) ~ "Full- or Part-Time",
    TRUE ~ NA_character_
  )
  
  final_dataset_imputed$employment_status <- factor(final_dataset_imputed$employment_status,
                                                    levels = c("Full- or Part-Time", "Retired/Not in Workforce"))
  cat("Created employment status groupings from employment\n")
}

######
# FINAL DATASET SUMMARY
######

cat("\n=== FINAL DATASET SUMMARY ===\n")
cat("Final dataset dimensions:", dim(final_dataset_imputed), "\n")
cat("Number of participants:", nrow(final_dataset_imputed), "\n")
cat("Number of variables:", ncol(final_dataset_imputed), "\n")

# Missing data summary
cat("\n=== MISSING DATA SUMMARY ===\n")
missing_summary <- sapply(final_dataset_imputed, function(x) sum(is.na(x)))
variables_with_missing <- missing_summary[missing_summary > 0]

if(length(variables_with_missing) > 0) {
  cat("Variables with missing data:\n")
  for(i in 1:length(variables_with_missing)) {
    var_name <- names(variables_with_missing)[i]
    missing_count <- variables_with_missing[i]
    missing_pct <- round((missing_count / nrow(final_dataset_imputed)) * 100, 1)
    cat(paste("  ", var_name, ":", missing_count, "(", missing_pct, "%)\n"))
  }
  
  # Overall completeness
  complete_cases <- sum(complete.cases(final_dataset_imputed))
  complete_pct <- round((complete_cases / nrow(final_dataset_imputed)) * 100, 1)
  cat("\nComplete cases:", complete_cases, "out of", nrow(final_dataset_imputed), 
      "(", complete_pct, "%)\n")
} else {
  cat("No missing data found in any variables!\n")
}

cat("\n=== DATA PREPARATION COMPLETE ===\n")
cat("Dataset 'final_dataset_imputed' is ready for multiple imputation analysis\n")
cat("Remember: alc_use_combined will be removed before imputation (use sex-specific versions)\n")
```


## MI Optimization

```{r}
#| label: Multiple Imputation Optimization

library(mice)
library(dplyr)

cat("\n=== MULTIPLE IMPUTATION OPTIMIZATION ===\n")

# --- Use dataset from preparation step ---
analysis_data <- final_dataset_imputed

# Remove alc_use_combined (redundant with sex-specific versions)
if("alc_use_combined" %in% names(analysis_data)) {
  analysis_data$alc_use_combined <- NULL
  cat("Removed alc_use_combined (using sex-specific variables instead)\n")
}

cat("Dataset dimensions:", dim(analysis_data), "\n")

# --- Ensure variables are correctly typed BEFORE imputation ---
cat("\n=== PREPARING VARIABLE TYPES ===\n")

# Binary variables (0/1) - convert to factor
binary_vars <- c("sex")
for(var in binary_vars) {
  if(var %in% names(analysis_data)) {
    analysis_data[[var]] <- factor(analysis_data[[var]])
  }
}
cat("Binary variables prepared:", length(intersect(binary_vars, names(analysis_data))), "\n")

# Unordered categorical (3+ levels) - convert to factor
unordered_categorical <- c("prov_terr", "prov_terr_region", "education_level", "employment_status", "gender")
for(var in unordered_categorical) {
  if(var %in% names(analysis_data)) {
    analysis_data[[var]] <- factor(analysis_data[[var]], ordered = FALSE)
  }
}
cat("Unordered categorical variables prepared:", length(intersect(unordered_categorical, names(analysis_data))), "\n")

# Ordered categorical - convert to ordered factor
ordered_vars <- c(
  "education", "income", "driving_freq", "employment",
  "side_effects_1_combined", "side_effects_2_combined",
  "side_effects_3_combined", "side_effects_4_combined",
  "safety_1_combined", "safety_2_combined",
  "safety_3_combined", "safety_4_combined",
  "adls_1_combined", "adls_2_combined",
  "dependence_1_combined", "dependence_2_combined", "dependence_3_combined",
  "med_burden_1", "med_burden2", "medburden_3", "med_burden_4",
  "op_use", "can_use", "caf_use", "nico_use", 
  "alc_sleep", "can_sleep", "melatonin_use", "op_sleep", 
  "quet_use", "traz_use", "otc_use",
  "alc_use_wmn", "alc_use_men"
)
for(var in ordered_vars) {
  if(var %in% names(analysis_data)) {
    analysis_data[[var]] <- factor(analysis_data[[var]], ordered = TRUE)
  }
}
cat("Ordered categorical variables prepared:", length(intersect(ordered_vars, names(analysis_data))), "\n")

# Continuous variables remain numeric
continuous_vars <- c(
  "age", "med_quant",
  "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", 
  "DBAS_Medications", "dbas_score",
  "Openness", "Conscientiousness", "Extraversion", "Agreeableness", "Neuroticism",
  "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", 
  "SURPS_Anxiety_Sensitivity",
  "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
  "osss_3_score", "phq2_score"
)
cat("Continuous variables:", length(intersect(continuous_vars, names(analysis_data))), "\n")

# Outcome variable (should NOT be imputed)
outcome_var <- "scrn_stopped_bzra"
if(outcome_var %in% names(analysis_data)) {
  analysis_data[[outcome_var]] <- factor(analysis_data[[outcome_var]])
  cat("Outcome variable prepared (will not be imputed)\n")
}

# --- Calculate missingness ---
cat("\n=== MISSINGNESS ANALYSIS ===\n")
overall_missing_pct <- mean(is.na(analysis_data)) * 100
m_impute <- max(20, min(100, ceiling(overall_missing_pct)))

cat("Overall missingness:", round(overall_missing_pct, 2), "%\n")
cat("Number of imputations (m):", m_impute, "\n")

# --- Initialize and customize imputation methods ---
cat("\n=== SETTING UP IMPUTATION METHODS ===\n")

init <- mice(analysis_data, maxit = 0, print = FALSE)
meth <- init$method
pred <- init$predictorMatrix

# Don't impute outcome variable
if(outcome_var %in% names(meth)) {
  meth[outcome_var] <- ""
  pred[, outcome_var] <- 0
}

# Don't impute sex-specific alcohol variables (they have structural missingness by design)
cat("\n=== HANDLING SEX-SPECIFIC ALCOHOL VARIABLES ===\n")
if("alc_use_wmn" %in% names(meth)) {
  meth["alc_use_wmn"] <- ""
  cat("alc_use_wmn will NOT be imputed (structural NA for men by design)\n")
}
if("alc_use_men" %in% names(meth)) {
  meth["alc_use_men"] <- ""
  cat("alc_use_men will NOT be imputed (structural NA for women by design)\n")
}

# Assign methods according to variable type
# Continuous: PMM
for(var in continuous_vars) {
  if(var %in% names(meth) && meth[var] != "") {
    meth[var] <- "pmm"
  }
}

# Binary: logreg
for(var in binary_vars) {
  if(var %in% names(meth) && meth[var] != "") {
    meth[var] <- "logreg"
  }
}

# Unordered categorical (3+ levels): polyreg
for(var in unordered_categorical) {
  if(var %in% names(meth) && meth[var] != "") {
    meth[var] <- "polyreg"
  }
}

# Ordered categorical: polr
for(var in ordered_vars) {
  if(var %in% names(meth) && meth[var] != "") {
    meth[var] <- "polr"
  }
}

cat("\nMethods assigned:\n")
cat("  PMM (continuous):", sum(meth == "pmm"), "\n")
cat("  logreg (binary):", sum(meth == "logreg"), "\n")
cat("  polyreg (unordered categorical):", sum(meth == "polyreg"), "\n")
cat("  polr (ordered categorical):", sum(meth == "polr"), "\n")
cat("  Not imputed:", sum(meth == ""), "\n")

# --- Simplify predictor matrix to avoid redundancy ---
cat("\n=== OPTIMIZING PREDICTOR MATRIX (OPTION 1: USE SUBSCALES) ===\n")

# Define DBAS subscales
dbas_subscales <- c("DBAS_Consequences", "DBAS_Worry_Helplessness", 
                    "DBAS_Expectations", "DBAS_Medications")

# OPTION 1: Use subscales (more granular), exclude total score
# Don't use dbas_score to predict subscales
pred["dbas_score", dbas_subscales] <- 0

# Don't use subscales to predict dbas_score
pred[dbas_subscales, "dbas_score"] <- 0

# For all OTHER variables (not DBAS-related), use ONLY subscales, NOT total score
other_vars <- setdiff(rownames(pred), c("dbas_score", dbas_subscales))
pred[other_vars, "dbas_score"] <- 0

cat("✓ DBAS predictor strategy: Using SUBSCALES to predict other variables\n")
cat("  dbas_score excluded as predictor for non-DBAS variables\n")
cat("  This preserves nuanced information while avoiding redundancy\n")

# Don't use derived regional/education/employment to predict originals
pred["prov_terr_region", "prov_terr"] <- 0
pred["prov_terr", "prov_terr_region"] <- 0
pred["education_level", "education"] <- 0
pred["education", "education_level"] <- 0
pred["employment_status", "employment"] <- 0
pred["employment", "employment_status"] <- 0

# Sex-specific alcohol variables should not predict each other
pred["alc_use_wmn", "alc_use_men"] <- 0
pred["alc_use_men", "alc_use_wmn"] <- 0

cat("\nPredictor matrix optimized\n")

# ========== DIAGNOSTIC CHECKS ==========
cat("\n=== DIAGNOSTIC CHECKS ===\n")

# 1. Check which variables need imputation
vars_to_impute <- names(meth[meth != ""])
cat("\nVariables to impute (", length(vars_to_impute), "):\n")
print(vars_to_impute)

# 2. Check missingness for each variable
cat("\n=== MISSINGNESS BY VARIABLE ===\n")
miss_summary <- sapply(analysis_data[vars_to_impute], function(x) sum(is.na(x)))
miss_pct <- round(100 * miss_summary / nrow(analysis_data), 2)
miss_df <- data.frame(
  Variable = names(miss_summary),
  Missing = miss_summary,
  Percent = miss_pct
)
print(miss_df[miss_df$Missing > 0, ])

# 3. Check predictor availability
cat("\n=== PREDICTOR AVAILABILITY ===\n")
for(var in vars_to_impute) {
  n_predictors <- sum(pred[var, ] > 0)
  if(n_predictors == 0) {
    cat("⚠ WARNING:", var, "has NO predictors!\n")
  } else if(n_predictors < 3) {
    cat("⚠ WARNING:", var, "has only", n_predictors, "predictor(s)\n")
  }
}

# 3b. Verify DBAS predictor strategy
cat("\n=== DBAS PREDICTOR VERIFICATION ===\n")
cat("For dbas_score:\n")
cat("  Using subscales as predictors:", sum(pred["dbas_score", dbas_subscales]) > 0, "\n")
cat("  Number of non-DBAS predictors:", sum(pred["dbas_score", other_vars]), "\n")

cat("\nFor DBAS subscales:\n")
for(subscale in dbas_subscales) {
  cat("  ", subscale, "- using dbas_score:", sum(pred[subscale, "dbas_score"]) > 0, 
      ", other predictors:", sum(pred[subscale, setdiff(colnames(pred), c("dbas_score", dbas_subscales))]), "\n")
}

cat("\nFor OTHER variables (sample check):\n")
sample_vars <- intersect(c("Neuroticism", "phq2_score", "can_use"), other_vars)
for(var in sample_vars) {
  cat("  ", var, "- using subscales:", sum(pred[var, dbas_subscales]), 
      ", using dbas_score:", sum(pred[var, "dbas_score"]), "\n")
}

# 4. Check for variables with too much missingness
high_miss_vars <- names(miss_pct[miss_pct > 50])
if(length(high_miss_vars) > 0) {
  cat("\n⚠ Variables with >50% missing:\n")
  print(high_miss_vars)
  cat("Consider removing these or using PMM\n")
}

# 5. Check for constant variables
cat("\n=== CHECKING FOR CONSTANT VARIABLES ===\n")
for(var in vars_to_impute) {
  if(is.factor(analysis_data[[var]])) {
    tab <- table(analysis_data[[var]], useNA = "no")
    if(length(tab) == 1) {
      cat("⚠ WARNING:", var, "has only 1 level (constant)!\n")
      cat("  Should not be imputed. Setting method to empty.\n")
      meth[var] <- ""
    } else if(length(tab) == 0) {
      cat("⚠ WARNING:", var, "is completely missing!\n")
      cat("  Cannot impute. Setting method to empty.\n")
      meth[var] <- ""
    }
  } else if(is.numeric(analysis_data[[var]])) {
    non_na <- analysis_data[[var]][!is.na(analysis_data[[var]])]
    if(length(unique(non_na)) == 1) {
      cat("⚠ WARNING:", var, "has no variation (constant)!\n")
      cat("  Should not be imputed. Setting method to empty.\n")
      meth[var] <- ""
    } else if(length(non_na) == 0) {
      cat("⚠ WARNING:", var, "is completely missing!\n")
      cat("  Cannot impute. Setting method to empty.\n")
      meth[var] <- ""
    }
  }
}

# 6. Check for sex variable issues
if("sex" %in% names(analysis_data)) {
  cat("\n=== SEX VARIABLE CHECK ===\n")
  cat("Class:", class(analysis_data$sex), "\n")
  cat("Levels:", levels(analysis_data$sex), "\n")
  cat("Table:\n")
  print(table(analysis_data$sex, useNA = "ifany"))
  cat("Missing:", sum(is.na(analysis_data$sex)), "\n")
  
  if(sum(is.na(analysis_data$sex)) > 0) {
    cat("Sex needs imputation, predictors:", sum(pred["sex", ] > 0), "\n")
  }
}

# 7. Verify sex-specific alcohol variable structure
cat("\n=== ALCOHOL VARIABLE VERIFICATION ===\n")
if("alc_use_wmn" %in% names(analysis_data) && "alc_use_men" %in% names(analysis_data)) {
  both_present <- sum(!is.na(analysis_data$alc_use_wmn) & !is.na(analysis_data$alc_use_men))
  cat("Cases with both alc_use_wmn AND alc_use_men:", both_present, "\n")
  
  if(both_present == 0) {
    cat("✓ Mutual exclusivity confirmed\n")
  } else {
    cat("⚠ WARNING: Variables are not mutually exclusive!\n")
  }
  
  cat("\nAlcohol variable structure:\n")
  cat("  alc_use_wmn: Women =", sum(!is.na(analysis_data$alc_use_wmn[analysis_data$sex == 1])),
      ", Men =", sum(!is.na(analysis_data$alc_use_wmn[analysis_data$sex == 2])), "\n")
  cat("  alc_use_men: Women =", sum(!is.na(analysis_data$alc_use_men[analysis_data$sex == 1])),
      ", Men =", sum(!is.na(analysis_data$alc_use_men[analysis_data$sex == 2])), "\n")
  
  cat("\nThese variables have structural missingness and will NOT be imputed.\n")
  cat("They will be used AS-IS in subsequent analyses.\n")
}

cat("\n=== UPDATED METHOD COUNTS ===\n")
cat("  PMM (continuous):", sum(meth == "pmm"), "\n")
cat("  logreg (binary):", sum(meth == "logreg"), "\n")
cat("  polyreg (unordered categorical):", sum(meth == "polyreg"), "\n")
cat("  polr (ordered categorical):", sum(meth == "polr"), "\n")
cat("  Not imputed:", sum(meth == ""), "\n")

# ========== END DIAGNOSTICS ==========
# --- Pilot run ---
cat("\n=== PILOT RUN (m=5, maxit=5) ===\n")
pilot <- tryCatch({
  mice(
    analysis_data,
    m = 5,
    maxit = 5,
    method = meth,
    predictorMatrix = pred,
    seed = 123,
    print = FALSE
  )
}, error = function(e) {
  list(error = TRUE, message = e$message)})

if(is.list(pilot) && !is.null(pilot$error)) {
  cat("✗ PILOT FAILED:\n")
  cat("  Error:", pilot$message, "\n")
  cat("\nTroubleshooting:\n")
  cat("  - Check for variables with too many missing values\n")
  cat("  - Check for perfect separation in categorical variables\n")
  cat("  - Consider using PMM for problematic variables\n")
} else {
  cat("✓ PILOT SUCCESSFUL\n")
  cat("Logged events:", length(pilot$loggedEvents), "\n")
  
  if(length(pilot$loggedEvents) > 0) {
    cat("\nLogged events details:\n")
    print(pilot$loggedEvents)}
  
  # Save convergence plot as PNG in Testing repo
  tryCatch({
    # Define the path to your Testing GitHub repo
    output_path <- file.path("~/Testing", "pilot_convergence_plot_use.png")
    
    png(output_path, width = 1400, height = 1000, res = 100)
    plot(pilot)
    dev.off()
    cat("\nConvergence plot saved:", output_path, "\n")
  }, error = function(e) {
    cat("\n⚠ Could not save convergence plot as PNG\n")
    cat("  Error:", e$message, "\n")})
  
  # Display plot interactively
  cat("\nDisplaying convergence plot interactively...\n")
  tryCatch({
    plot(pilot)
    cat("✓ Interactive plot displayed (check your Plots pane)\n")
  }, error = function(e) {
    cat("⚠ Could not display interactive plot\n")
    cat("  Error:", e$message, "\n")
  })}

# --- Recommendations ---
cat("\n=== NEXT STEPS ===\n")
cat("If pilot looks good:\n")
cat("1. Review pilot_convergence.png (saved) or check your Plots pane\n")
cat("2. Run final imputation with m =", m_impute, ", maxit = 30\n")
cat("3. Use appropriate methods for each variable type\n")
cat("\nNOTE: Sex-specific alcohol variables (alc_use_wmn, alc_use_men) are not imputed.\n")
cat("      Use them as-is in analyses, treating structural NAs appropriately.\n")
cat("\nDBAS STRATEGY: Subscales predict other variables; total score does not.\n")
cat("               This provides nuanced information while avoiding redundancy.\n")
```


## Multiple Imputation

```{r}
#| label: Multiple Imputation Optimization

library(mice)
library(dplyr)

cat("\n=== MULTIPLE IMPUTATION OPTIMIZATION ===\n")

# --- Use dataset from preparation step ---
analysis_data <- final_dataset_imputed

# Remove alc_use_combined (redundant with sex-specific versions)
if("alc_use_combined" %in% names(analysis_data)) {
  analysis_data$alc_use_combined <- NULL
  cat("Removed alc_use_combined (using sex-specific variables instead)\n")
}

cat("Dataset dimensions:", dim(analysis_data), "\n")

# --- Ensure variables are correctly typed BEFORE imputation ---
cat("\n=== PREPARING VARIABLE TYPES ===\n")

# Binary variables (0/1) - convert to factor
binary_vars <- c("sex")
for(var in binary_vars) {
  if(var %in% names(analysis_data)) {
    analysis_data[[var]] <- factor(analysis_data[[var]])
  }
}
cat("Binary variables prepared:", length(intersect(binary_vars, names(analysis_data))), "\n")

# Unordered categorical (3+ levels) - convert to factor
unordered_categorical <- c("prov_terr", "prov_terr_region", "education_level", "employment_status", "gender")
for(var in unordered_categorical) {
  if(var %in% names(analysis_data)) {
    analysis_data[[var]] <- factor(analysis_data[[var]], ordered = FALSE)
  }
}
cat("Unordered categorical variables prepared:", length(intersect(unordered_categorical, names(analysis_data))), "\n")

# Ordered categorical - convert to ordered factor
ordered_vars <- c(
  "education", "income", "driving_freq", "employment",
  "side_effects_1_combined", "side_effects_2_combined",
  "side_effects_3_combined", "side_effects_4_combined",
  "safety_1_combined", "safety_2_combined",
  "safety_3_combined", "safety_4_combined",
  "adls_1_combined", "adls_2_combined",
  "dependence_1_combined", "dependence_2_combined", "dependence_3_combined",
  "med_burden_1", "med_burden2", "medburden_3", "med_burden_4",
  "op_use", "can_use", "caf_use", "nico_use", 
  "alc_sleep", "can_sleep", "melatonin_use", "op_sleep", 
  "quet_use", "traz_use", "otc_use",
  "alc_use_wmn", "alc_use_men"
)
for(var in ordered_vars) {
  if(var %in% names(analysis_data)) {
    analysis_data[[var]] <- factor(analysis_data[[var]], ordered = TRUE)
  }
}
cat("Ordered categorical variables prepared:", length(intersect(ordered_vars, names(analysis_data))), "\n")

# Continuous variables remain numeric
continuous_vars <- c(
  "age", "med_quant",
  "DBAS_Consequences", "DBAS_Worry_Helplessness", "DBAS_Expectations", 
  "DBAS_Medications", "dbas_score",
  "Openness", "Conscientiousness", "Extraversion", "Agreeableness", "Neuroticism",
  "SURPS_Impulsivity", "SURPS_Sensation_Seeking", "SURPS_Hopelessness", 
  "SURPS_Anxiety_Sensitivity",
  "CISS_Avoidance_Style", "CISS_Task_Style", "CISS_Emotional_Style",
  "osss_3_score", "phq2_score"
)
cat("Continuous variables:", length(intersect(continuous_vars, names(analysis_data))), "\n")

# Outcome variable (should NOT be imputed)
outcome_var <- "scrn_stopped_bzra"
if(outcome_var %in% names(analysis_data)) {
  analysis_data[[outcome_var]] <- factor(analysis_data[[outcome_var]])
  cat("Outcome variable prepared (will not be imputed)\n")
}

# --- Calculate missingness ---
cat("\n=== MISSINGNESS ANALYSIS ===\n")
overall_missing_pct <- mean(is.na(analysis_data)) * 100
m_impute <- max(20, min(100, ceiling(overall_missing_pct)))

cat("Overall missingness:", round(overall_missing_pct, 2), "%\n")
cat("Number of imputations (m):", m_impute, "\n")

# --- Initialize and customize imputation methods ---
cat("\n=== SETTING UP IMPUTATION METHODS ===\n")

init <- mice(analysis_data, maxit = 0, print = FALSE)
meth <- init$method
pred <- init$predictorMatrix

# Don't impute outcome variable
if(outcome_var %in% names(meth)) {
  meth[outcome_var] <- ""
  pred[, outcome_var] <- 0
}

# Assign methods according to variable type
# Continuous: PMM
for(var in continuous_vars) {
  if(var %in% names(meth) && meth[var] != "") {
    meth[var] <- "pmm"
  }
}

# Binary: logreg
for(var in binary_vars) {
  if(var %in% names(meth) && meth[var] != "") {
    meth[var] <- "logreg"
  }
}

# Unordered categorical (3+ levels): polyreg
for(var in unordered_categorical) {
  if(var %in% names(meth) && meth[var] != "") {
    meth[var] <- "polyreg"
  }
}

# Ordered categorical: polr
for(var in ordered_vars) {
  if(var %in% names(meth) && meth[var] != "") {
    meth[var] <- "polr"
  }
}

cat("Methods assigned:\n")
cat("  PMM (continuous):", sum(meth == "pmm"), "\n")
cat("  logreg (binary):", sum(meth == "logreg"), "\n")
cat("  polyreg (unordered categorical):", sum(meth == "polyreg"), "\n")
cat("  polr (ordered categorical):", sum(meth == "polr"), "\n")
cat("  Not imputed:", sum(meth == ""), "\n")

# --- Simplify predictor matrix to avoid redundancy ---
# Don't use dbas_score to predict subscales or vice versa
pred["dbas_score", c("DBAS_Consequences", "DBAS_Worry_Helplessness", 
                     "DBAS_Expectations", "DBAS_Medications")] <- 0
pred[c("DBAS_Consequences", "DBAS_Worry_Helplessness", 
       "DBAS_Expectations", "DBAS_Medications"), "dbas_score"] <- 0

# Don't use derived regional/education/employment to predict originals
pred["prov_terr_region", "prov_terr"] <- 0
pred["prov_terr", "prov_terr_region"] <- 0
pred["education_level", "education"] <- 0
pred["education", "education_level"] <- 0
pred["employment_status", "employment"] <- 0
pred["employment", "employment_status"] <- 0

cat("\nPredictor matrix optimized\n")

# ========== DIAGNOSTIC CHECKS ==========
cat("\n=== DIAGNOSTIC CHECKS ===\n")

# 1. Check which variables need imputation
vars_to_impute <- names(meth[meth != ""])
cat("\nVariables to impute (", length(vars_to_impute), "):\n")
print(vars_to_impute)

# 2. Check missingness for each variable
cat("\n=== MISSINGNESS BY VARIABLE ===\n")
miss_summary <- sapply(analysis_data[vars_to_impute], function(x) sum(is.na(x)))
miss_pct <- round(100 * miss_summary / nrow(analysis_data), 2)
miss_df <- data.frame(
  Variable = names(miss_summary),
  Missing = miss_summary,
  Percent = miss_pct
)
print(miss_df[miss_df$Missing > 0, ])

# 3. Check predictor matrix for each variable to impute
cat("\n=== PREDICTOR AVAILABILITY ===\n")
for(var in vars_to_impute) {
  n_predictors <- sum(pred[var, ] > 0)
  if(n_predictors == 0) {
    cat("⚠ WARNING:", var, "has NO predictors!\n")
  } else if(n_predictors < 3) {
    cat("⚠ WARNING:", var, "has only", n_predictors, "predictor(s)\n")
  }
}

# 4. Check for variables with too much missingness
high_miss_vars <- names(miss_pct[miss_pct > 50])
if(length(high_miss_vars) > 0) {
  cat("\n⚠ Variables with >50% missing:\n")
  print(high_miss_vars)
  cat("Consider removing these or using PMM\n")
}

# 5. Check for constant variables (no variation)
cat("\n=== CHECKING FOR CONSTANT VARIABLES ===\n")
for(var in vars_to_impute) {
  if(is.factor(analysis_data[[var]])) {
    tab <- table(analysis_data[[var]], useNA = "no")
    if(length(tab) == 1) {
      cat("⚠ WARNING:", var, "has only 1 level (constant)!\n")
      cat("  Should not be imputed. Setting method to empty.\n")
      meth[var] <- ""
    } else if(length(tab) == 0) {
      cat("⚠ WARNING:", var, "is completely missing!\n")
      cat("  Cannot impute. Setting method to empty.\n")
      meth[var] <- ""
    }
  } else if(is.numeric(analysis_data[[var]])) {
    non_na <- analysis_data[[var]][!is.na(analysis_data[[var]])]
    if(length(unique(non_na)) == 1) {
      cat("⚠ WARNING:", var, "has no variation (constant)!\n")
      cat("  Should not be imputed. Setting method to empty.\n")
      meth[var] <- ""
    } else if(length(non_na) == 0) {
      cat("⚠ WARNING:", var, "is completely missing!\n")
      cat("  Cannot impute. Setting method to empty.\n")
      meth[var] <- ""
    }
  }
}

# 6. Check for sex variable issues
if("sex" %in% names(analysis_data)) {
  cat("\n=== SEX VARIABLE CHECK ===\n")
  cat("Class:", class(analysis_data$sex), "\n")
  cat("Levels:", levels(analysis_data$sex), "\n")
  cat("Table:\n")
  print(table(analysis_data$sex, useNA = "ifany"))
  cat("Missing:", sum(is.na(analysis_data$sex)), "\n")
  
  # If sex has missing values, check if it has predictors
  if(sum(is.na(analysis_data$sex)) > 0) {
    cat("Sex needs imputation, predictors:", sum(pred["sex", ] > 0), "\n")
  }
}

# 7. Ensure sex-specific alcohol variables exist and have the right relationship
cat("\n=== ALCOHOL VARIABLE CHECK ===\n")
if("alc_use_wmn" %in% names(analysis_data) && "alc_use_men" %in% names(analysis_data)) {
  # These should not both have values for the same person
  # They should be mutually exclusive based on sex
  both_present <- sum(!is.na(analysis_data$alc_use_wmn) & !is.na(analysis_data$alc_use_men))
  if(both_present > 0) {
    cat("⚠ WARNING:", both_present, "cases have both alc_use_wmn and alc_use_men!\n")
  }
  
  # Make sure they don't predict each other
  pred["alc_use_wmn", "alc_use_men"] <- 0
  pred["alc_use_men", "alc_use_wmn"] <- 0
  cat("Sex-specific alcohol variables set to not predict each other\n")
}

cat("\n=== UPDATED METHOD COUNTS ===\n")
cat("  PMM (continuous):", sum(meth == "pmm"), "\n")
cat("  logreg (binary):", sum(meth == "logreg"), "\n")
cat("  polyreg (unordered categorical):", sum(meth == "polyreg"), "\n")
cat("  polr (ordered categorical):", sum(meth == "polr"), "\n")
cat("  Not imputed:", sum(meth == ""), "\n")

# ========== END DIAGNOSTICS ==========

# --- Pilot run ---
cat("\n=== PILOT RUN (m=5, maxit=5) ===\n")

pilot <- tryCatch({
  mice(
    analysis_data,
    m = 5,
    maxit = 5,
    method = meth,
    predictorMatrix = pred,
    seed = 123,
    print = FALSE
  )
}, error = function(e) {
  list(error = TRUE, message = e$message)
})

if(is.list(pilot) && !is.null(pilot$error)) {
  cat("✗ PILOT FAILED:\n")
  cat("  Error:", pilot$message, "\n")
  cat("\nTroubleshooting:\n")
  cat("  - Check for variables with too many missing values\n")
  cat("  - Check for perfect separation in categorical variables\n")
  cat("  - Consider using PMM for problematic variables\n")
} else {
  cat("✓ PILOT SUCCESSFUL\n")
  cat("Logged events:", length(pilot$loggedEvents), "\n")
  
  if(length(pilot$loggedEvents) > 0) {
    cat("\nLogged events details:\n")
    print(pilot$loggedEvents)
  }
  
  # Save convergence plot
  pdf("pilot_convergence.pdf", width = 14, height = 10)
  plot(pilot)
  dev.off()
  cat("\nConvergence plot saved: pilot_convergence.pdf\n")
}

# --- Recommendations ---
cat("\n=== NEXT STEPS ===\n")
cat("If pilot looks good:\n")
cat("1. Review pilot_convergence.pdf for chain stability\n")
cat("2. Run final imputation with m =", m_impute, ", maxit = 30\n")
cat("3. Use appropriate methods for each variable type\n")
```




